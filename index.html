<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">What&#39;s in a Pod?</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="What's in a Pod?">
  <meta name="citation_author" content="Ruben Dedecker" />
  <meta name="citation_author" content="Wout Slabbinck" />
  <meta name="citation_author" content="Ruben Verborgh" />
  <meta name="citation_author" content="Jesse Wright" />
  <meta name="citation_author" content="Pieter Colpaert" />
  
  <meta name="citation_publication_date" content="2022/08/29" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="whats-in-a-pod">What’s in a Pod?</h1>

  <h2 id="understanding-solids-decentralized-knowledge-graphs">Understanding Solid’s decentralized knowledge graphs</h2>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://rubendedecker.be/" typeof="foaf:Person schema:Person" resource="https://rubendedecker.be/#me">Ruben Dedecker</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Wout Slabbinck</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Jesse Wright</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Pieter Colpaert</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
Department of Electronics and Information Systems,
Ghent University – imec</li>
  </ul>

  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Solid ecosystem provides specifications
for the publication and consumption of decentralized permissioned data,
stored across multiple locations called <q>Pods</q>.
<!-- Need         -->
A disconnect exists between the practical notion of a Pod
and the protocol that provides access to its data,
creating confusion as to what exactly a Pod is
and how it relates to the technical specifications.
To reinstate clarity,
<!-- Task         -->
we examined possible interpretations of the technological underpinnings,
and compared them from the viewpoints of
storage, publication and query.
<!-- Object       -->
First, this article details
the current understanding of Pods as a collection of Linked Data documents.
Second,
we propose a wider definition
in which a Solid Pod is fundamentally a knowledge graph,
which can be accessed through various Web APIs
that act as views in a database sense.
<!-- Findings     -->
We argue that the latter zoomed-out perspective
enables accessing and querying knowledge within Pods
in more flexible and sustainable ways.
<!-- Conclusion   -->
These insights are crucial to reduce
the dependency of Solid apps on concrete APIs
and local assumptions about the shape and organization of data
and the resulting performance.
<!-- Perspectives -->
The suggested broader perspective supports Solid with
evolving into a heterogeneous but interoperable ecosystem
that accommodates for a multitude of data access patterns.</p>

    </div>
</section>

</header>

<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Introduction</h2>
      <p>In the current state of the Web, companies gather and store large amounts of data on centralized locations, inaccessible for the public and other companies. 
The concepts of data control and privacy have since lost a lot of meaning, as user data is scattered over these centralized data silos with little to no opportunity for users to reuse this data.
<!-- The Solid Proposal --> 
Through the Solid project, Sir Tim Berners Lee, the inventor of the World Wide Web, has aimed to revitalize these concepts of identity and data ownership and privacy for the Web <span class="references">[<a href="#ref-1">1</a>]</span>.
Proposed in 2016 as a decentralized platform for social Web applications <span class="references">[<a href="#ref-2">2</a>]</span>, Solid defines the concept of personal online datastores (pod) as online data spaces that enable the storage and management of personal data over the Web, where users control the permissions for applications and agents to interact with their data pod.
<!-- Permissions and splitting apps and data -->
To create such an ecosystem of a decentralized network of data pods over the Web, 
the concept of separation of data and application is an important premise.
<!-- Semantics are key -->
Where historically applications can rely on implicit assumptions in the structuring, context and other semantics of data, in the context of online data stores shared by applications and users, assumptions that do not hold for the ecosystem are broken and must be captured in the semantics of the data.
These semantics form the basis for interoperability of data between applications, as these semantics can be interpreted by other applications to reuse this existing data, where prior local assumptions required for the processing of this data may have prevented this.</p>

      <!-- Solid as a set of interfaces -->
      <p>To achieve these goals, Solid is based on a set of specifications that define the protocol to interact with Solid data pods on the Web.
These interfaces define how to add, read and remove resources data on a Solid pod, how to authenticate and how to set permissions for data on your pod for agents and applications on the network.
<!-- Especially the LDP interface -->
To interface with the data stored on a Solid pod, the Linked Data Platform (LDP) specification <a href="">TODO::cite</a> is used. 
The LDP specification proposes an organizational scheme where data is bundled into resources.
These resources are then organized in a hierarchical structure of resources and containers on the data pod.</p>

      <!-- That lead to application bias in the data -->
      <p>As this organization of data in resources and the organization of these resources on the Solid pod is currently done by application, the local assumptions and optimizations made by applications in this organizational structure that is not shared by the ecosystem leads to 
difficulty</p>

      <!-- Made worse by lack of authoritative definition -->
      <p>Next to this, we also notice a lack of an authoritative definition for Solid. 
As the solid ecosystem expands through new initiatives and industry attention is starting to pick up, the lack of an authoritative definition for Solid is starting to show as new initiatives, as the definition shifts more from the original vision towards an understanding of Solid as a sum of the currently used specifications to achieve this vision.</p>

      <!-- We propose a new perspective -->
      <p>With this work, we propose the perspective of viewing a Solid pod as a permissioned knowledge graph that can be exposed over the Web using a multitude of interfaces.
We argue that the organizational structure that the Linked Data Platform specification imposes on the Solid ecosystem through its constraints and degrees of freedom for applications to structure their data, separation of application and data and hence data interoperability is limited.
<!-- With hopes of steering discussion to original vision -->
- Using this work, we hope to steer the discussion over Solid towards the goals of separating application and data through use of semantics in the stored data with the perspective of Solid pods as permissioned knowledge graphs that can be exposed over the Web using a multitude of interfaces.</p>

      <!-- Sections -->
      <p>In <a href="#problem_statement">Section 2</a>, we define how a mismatch in organization and real-world structure of data can lead to problems through local assumptions and optimizations by applications.
<a href="#vision">Section 3</a> shows the proposed perspective of viewing Solid data pods as permissioned knowledge graphs that can be exposed over a multitude of APIs.
In <a href="#comparison">Section 4</a>, we argue through comparisons of specific use-cases how interfaces influence the organization and structure of the data, and can lead to coupling between application and data through localized assumptions, after which a conclusion is formulated in <a href="#conclusion">Section 5</a>.</p>

      <!-- 



The goal of the Solid platform is to present a platform that separates applications and data, creating an ecosystem where multiple applications can seamlessly work with the same data [TODO::cite from somewhere? ask Ruben V?]().
For such an ecosystem to exist, the concept of separation of data and application is an important premise.
Through the separation of data and application, implicit assumptions between application and data are broken and must be captured in the semantics of the data.
These semantics then form the basis of the interoperability of this data between applications, as other applications may now use these semantics to make sense of and reuse existing data, where prior local assumptions by applications may have prevented this.

The Solid project provides a platform based on a set of open standards to manage and interact with data in a Personal Online Datastore (POD) <span class="references">\[<a href="#ref-2">2</a>\]</span>.
With the goal of facilitating the integration of data for applications over the Web, 
through giving individuals control over this data through deciding access rights and choosing the applications and services allowed to interact with this data, 
new paradigms are needed.

However, as the specifications evolved, we see an evolution in direction of Solid being equated to the specifications used to implement the vision, as opposed to the original vision of a next step for the Web to provide separation between data and applications. -->

      <!-- A definition for Solid -->

      <!-- ### Separating data and applications
To achieve an ecosystem where different applications can work with the same data, the separation between the data and the applications / services working with the data is an important premise. -->

      <!-- ### Semantics and data
A key enabler of this separation is the use of RDF and the adding of semantics to data.
The semantic Web was introduced as an extension to the Web to make data machine-readable <span class="references">\[<a href="#ref-3">3</a>\]</span>.
Two decades later, the standards introduced are more relevant than ever in the goal to creating ecosystems that enable data integration and interoperability for applications.
Where large portions of the semantics of currently available data over the web are  historically stored in documentation of APIs scattered over the internet, semantics in data allow the expressiveness of storing these semantics in the data itself. Instead of requiring to read the documentation of a data source to know that `api.com/users/1234/contacs/` results in a JSON list of contacts for user 1234, the Relational Data Format (RDF) enables us to write these semantics in the data itself, where `</users/1234/> foaf:knows </users/1235>`. Irrespective of the interface exposing this data, the relation between both users can be discovered from the semantics in the data without requiring specific understanding of how the data was retrieved and the implicit semantics that were captured in the exposing API.
 -->

      <!-- 
1. werkt dereferencability nog?
2. persistent URIs
3. openlijk toegeven dat het een discussion document is

bezwaren par heijs - wat doe je met blank nodes?
blank nodes -> resource | is vrij contained
blank nodes -> graph | goed weten wat ermee bedoeld wordt - scoping van KG - belangrijk voor updates 

5. contradicting data

framen als discussion

wat als - perspective
 -->

    </div>
</section>

  <section id="problem_statement" inlist="" rel="schema:hasPart" resource="#problem_statement">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Problem statement</h2>
      <!-- Solid requires splitting of apps and data through semantics -->
      <p>To achieve the envisioned ecosystem of data integration and interoperability, the Solid ecosystem relies on the premise that it is possible to separate applications and data in a meaningful way, so that different applications can work with the same data stored in a data pod. The key here is that the semantics of the stored data can help applications to discover the data they need in a pod, and can reuse, adapt and work with this data without requiring to adapt a specific interface and documentation to interact with the data for each new pod data source they connect with <a href="">TODO:: cite Ruben V blog</a>.</p>

      <h3 id="the-ldp-interface">The LDP interface</h3>
      <!-- LDP leads to mismatch between the restrictions imposed on how data can be stored, and the real world  -->
      <p>As the protocol chosen for read / write operations on a Solid pod, the Linked Data Platform (LDP) specification <span class="references">[<a href="#ref-4">4</a>]</span> holds a central role in the current Solid ecosystem in enabling the promise of data interoperability. 
This specification organizes data by defining the concepts of resources and containers, and defining a set of rules for HTTP(S) operations that can be used to create, read, modify and delete these resources and containers.
Resources are presented as either being a collection of RDF data, or being a non-RDF resource such as an image.
As resources are organized under containers similarly to how files and directories are structured on a file system, the LDP interface provides a very familiar interface for developers to work with data on a Solid pod, as they can in a sense equate it to a remote file system that is operated over HTTP(S).</p>

      <!-- applications are required to make localized assumptions and optimizations to read and write data on a Solid pod over LDP -->
      <p>However, though LDP provides a familiar interface, it creates the restriction of having to bundle data into resources and organizing these resources in a hierarchical structure on the Solid pod. Apart from these restrictions, the LDP interface provides a lot of degrees of freedom as to how applications can organize their data into separate resources, and how these resources can be stored on a Solid pod.
The combination of restricting the way data can be stored on a pod to bundling data into resources, and organizing them over a hierarchical structure, means that the application holds full responsibility over how data is bundled into these resources, and how they are organized on a pod.
This leads to a number of issues:
(i) as solid restricts the granularity of setting permissions to resources and containers on a Solid pod, applications indirectly dictate the granularity over which users can control the access to their data.
(ii) the hierarchical structure imposed when storing data may not conform to real-world requirements for structuring the data, it requires applications to create local assumptions for the structuring of data, leading to organizational structures for data that may make discovery, interoperability and permission management more difficult.
(iii) as developers are allowed full freedom in how data is being written to a data pod, developers may choose to make local assumptions of data, encoding meaning and context into the locations of resources and the bundling of data in resources that may not hold for the rest of the ecosystem. This means the loss of important semantic information for other applications that may lack this context to interact with this data.</p>

      <!-- We see this as a consequence of LDP certain restrictions, but also leaving a lot of degrees of freedom, leavind developers free to use a Solid pod as a remote file system -->
      <p>We view that the above difficulties for applications working with Solid pods over the Linked Data Platform interface can be derived from the Linked Data Platform interface behaving as an interface where applications can define their own interface on top of LDP as to how they interact with their data in ways that are not shared by the rest of the Solid ecosystem and that are not semantically described in the stored data.
These findings make the core premise of the Solid ecosystem providing separation between applications and data more difficult, as the requirement for applications to add sufficient semantic information to their data to make it interoperable within the ecosystem can easily be bypassed by applications, missing the original vision for Solid as an  where data and applications are separated and where Solid marks the transition from an API-integration ecosystem where applications needing to integrate APIs to gain access to different data sources to an ecosystem of data-integration where applications can integrate data from different data sources through the available semantics in the data.</p>

      <h3 id="a-lack-of-definition">A lack of definition</h3>
      <p>As the specifications for Solid evolved over time, we noticed that because of a lack of authoritative definition for Solid (that we know of), the definition for what Solid is started to shift.
From being initially described as “<em>a decentralized platform for social Web applications</em>” <span class="references">[<a href="#ref-2">2</a>]</span> <a href="">TODO:: full citation style????</a>, over time initiatives within the Solid ecosystem started providing their own definitions as to what Solid is based on their vision of the ecosystem.
On the Solid project <a href="">TODO::reference - https://solidproject.org/</a> website, we find that “<em>Solid is a specification that lets people store their data securely in decentralized data stores called Pods.</em>”.
The Inrupt website <a href="">TODO::reference - https://inrupt.com/solid/</a> states that “<em>Solid is a technology for organizing data, applications, and identities on the web.</em>”.</p>

      <p>We fear this lack of consistency in the definition of Solid may create confusion about how , and may give the ecosystem a semblance of a Linked Data Platform ecosystem where applications can store their data, missing the original vision of an ecosystem where the separation of applications and data through semantic enrichment of data creates provides interoperability between applications and data as a next step for the Web.</p>

      <p><a href="">TODO:: this ending not 100% pleased with</a>.</p>

      <!-- 
----------------------------
OLD STUFF
----------------------------
 -->

      <!-- 
Additionally, we notice that the inconsistency in used terminology to the identity of Solid as a platform, technology, specification or protocol. Next to this, from our experience with the tooling and initiatives,
In contrast, the current specifications (WAC, ACP), research [TODO:: find something good here??]() and tooling is all focused on viewing Solid as a Linked Data Platform interface.
[TODO:: we need more content here to prove this point]().

Because of this notion of a Solid POD being equated to the Linked Data Platform interface is exposes, in contrast to viewing this interface as a means to an end to achieve the original goal of splitting applications and data while providing semantics in the data itself, we argue that this current perspective enforces the problems that currently exist with using the Linked Data Platform specification as a base for the Solid ecosystem and limits the potential for innovation and solutions that the Solid ecosystem can bring to the Web.

 -->

      <!-- Missing the point: We argue that LDP with WAC / ACP has the goal of creating a developer-friendly approach of presenting developers with a file-system like interface to use data over the Web, with a we'll fix it later attitude. But this leads to developers using this interface just like a file system and missing the point of adding semantics to their data to help the interoperability. -->

      <!-- 
It puts constraints on the data - resource granularity, hierarchical structuring, but also leaves degrees of freedom used to create additional semantics not captured in the data.
This freedom is used to create API's in the data through local assumptions creating semantics that may not be captured 
However, if we look at the implementation these definitions differ We notice a lack of proper definition for Solid, nor a guideline for used terminology (protocol, platform, ecosystem, ...).in the data itself.
Little support for interoperability in its base form.

#### Resources are organized in a hierarchical structure using containers.
This hierarchical structure 


#### Resources do not impose any structure on data



In this bundling of data in resources and organizing these resources in a hierarchical structure, we see a mismatch with how 

In this bundling of data in resources

In this hierarchical structuring of data, we see a mismatch with the structuring of real-world data.
As applications 
As data must be collected in resources and placed in a hiera
 -->

      <!-- 


-----------------

### Solid as a Linked Data Platform interface

LDP as a meta-API where applications are able to model their data needs.
It puts constraints on the data - resource granularity, hierarchical structuring, but also leaves degrees of freedom used to create additional semantics not captured in the data.
This freedom is used to create API's in the data through local assumptions creating semantics that may not be captured 
However, if we look at the implementation these definitions differ We notice a lack of proper definition for Solid, nor a guideline for used terminology (protocol, platform, ecosystem, ...).in the data itself.
Little support for interoperability in its base form.

#### A mismatch between data organization and the real world
is often caused by the Linked Data Platform interface being restrictive in the way data can be organized over the interface.
The Linked Data Platform specification organizes data in a hierarchical structure, where real-world data does not always follow a hierarchical structure.



#### Semantics in data organization
in applications and 


#### Localized assumptions and optimizations
made by applications in the structure of data stored on a data pod leads to ...

#### Applications indirectly dictate the permission structure
in their structuring of data on the data pod.
As applications structure data stored on the data pod, 
the resulting data organization on the pod dictates how permissions can be set over this data.
As the data is structured in resources using the hierarchical structuring of the Linked Data Platform interface,
permission granularity over this data is limited to the size of the chosen resources, and not on individual data triples in these resources (in case of RDF resources).
Additionally, interactions with this data is limited to the structuring of these resources, as [TODO:: what more should we put here??]().
 -->

      <!-- 


--------------------------------------------

#### Data granularity
A consequence of using this specification is that data must be organized in resources, as this is the only form of data that can be managed using Linked Data Platform. This requires applications to make local assumptions as to what constitutes a resource and how application data should be distributed over resources in a data pod. As resources are the only interface, other data structures such as databases are impossible, and must be emulated on the client side over the resources exposed by the LDP interface.

#### Organizational semantics
As resources are stored in a hierarchical way due to the nature of the Linked Data Platform specification, the organization of data in a hierarchical order may carry implicit semantics in the organization of resources on a data pod. We see this return in the original paper<span class="references">\[<a href="#ref-2">2</a>\]</span>, where the example is given of an application storing events using a URI path structure based on dates (i.e., /2016/05/01/event1). The problem with these localized assumptions is they do not hold for the ecosystem, and form an application specific API built on Linked Data Platform [TODO:: what more?]().

#### Hierarchical bias
The hierarchical organization of data on a pod also leads to data separation between applications. We see this with e.g. Digita [TODO::source]() providing a separate container for each app, in the same way that the `Program Files` folder provides a location for applications to store data. While this mitigates issues of overwriting data, and adds implicit context to data based on its location (at least for the application managing a certain data space), this comes at the cost of data discovery and integration [TODO:: what more?]().

#### LDP as a meta-API
We argue that the Linked Data Platform interface is not an API, but a meta-API that can organize data in an infinite amount of ways. In the current environment, applications are forced to make local assumptions, and create application-specific API's on the Solid data pods through localized assumptions that do not hold for the ecosystem. This comes at the cost of data discovery and interoperability with different applications that do not share the same assumptions.

### API-integration versus data-integration

As the goal for interoperability of online data spaces is to move from the paradigm of API integration to mode data integration centered approaches of data publishing, we see that Linked Data Platform in it's current state creates API integration issues for applications through localized assumptions in data organization and format / shape [TODO:: maybe also make the point of format / shape integration a bit more]().



The original paper proposes a solution for data discovery through providing a SPARQL interface that runs on top of the data organized in the Linked Data Platform, where every resource serves as its own SPARQL endpoint (https://github.com/nodeSolidServer/node-solid-server/issues/962) which has since been removed from the spec -> this was no solution after all so maybe this should be casually mentioned as a sidenote?
 -->

      <!-- 

As a consequence of these decisions, using the Linked Data Platform interface, reading this contact data requires the knowledge of where the data is stored, and the formatting in which the data is stored to work with the data.

As a consequence of using LDP for the organization of resources on a data pod, the main discovery mechanism over this interface is link traversal through the LDP interface.
This is however a limited approach, as in case an agent tries to retrieve information stored in a public resource at at `&lt;pod_uri&gt;/private/public`, where the parent container `&lt;pod_uri&gt;/private/` is set to be private, the resource cannot be discovered unless the exact URI can be discovered through another means.

In their "extensions to LDP" part of the paper, they propose the "PUT" extension to LDP, with the example of a calendar application
that uses a URI path structure based on dates (i.e., /2016/05/01/event1). A PUT request is to create a new resource called event1,
as well as the missing month (i.e., 05) and day (i.e., 01) containers under /2016.
Here we see again the reliance on the LDP bias (using the slash semantics as semantic information over the stored data instead of explicitly tagging the data with the information), that leads to assumptions being required to discover the data.

The complex data retrieval proposed through SPARQL mentions that optionally a SPARQL endpoint can be provided on a data pod, enabling more complex data queries from a pod, where rdf-resources and metadata for non-rdf resources can be exposed over the interface.
This is to address shortcomings in the LDP interface of not being able to express complex data retrieval operations such as filtering and aggregation. Also proposed here is that pod servers may be responsible for evaluating queries spanning multiple pods by forwarding requests for additional data to other pod servers.

In their related work, it states:
Solid has a strong focus on decoupling data from
applications and in addition ensuring that applications have a simple, generic
and well defined way to access the data stored in the users’ pods.




In Section 5, the paper presents the POD Management system. It defines that pods use LDP to organize data in containers that group resources with every resource and container having their own URI. A pod server should support 
- LDP
- patching (N3-patch, former SPARQL update)
- access control lists (ACL), potentially to be updated to access control policies (ACP).
- live updates
- optionally SPARQL

They advise storage mechanisms for RDF data to use triple stores to facilitate querying.

From all this information, we infer that their approach is focused on data discovery and querying happening mainly over a SPARQL interface that has a full index of all data that is available to the agent querying over the pod and can fulfill these requirements on the server side.



### LDP as an API
Additionally, we also argue that LDP is not an API: it’s a meta-API. 
There are still an infinite amount of ways to expose knowledge over LDP. 
We notice existing work and apps get this wrong[TODO::cite]().


Because of this, we see that the promise of Solid moving the equation from API-integration to data-integration does not hold.
As LDP cannot be viewed as a simple API, the problem of integrating different API's to access data from different sources 
has been translated into requiring knowledge of different writing / storage methods to access data stored on different pods by different applications,
leading to a different kind of API integration, without providing the data-integration that was promised. -->

      <!-- 


------------------------------------------------------------------




A disconnect exists between the practical notion of a Pod and the protocol that provides access to its data, creating confusion as to what exactly a Pod is and how it relates to the technical specifications.

- LDP creates biases in the stored data?
- data integration issues w LDP?


- spec updates evolved the understanding of Solid pods
- the technical specifications put limits on the way data can be interacted with
- to attain the goal of replacing the API integration with data integration, have to work around the limitations of LDP or build alternative interfaces on top.




The current state of LDP makes us think of pods as collections of Linked Data Documents

We see a fundamental mismatch with usage.
We see different apps making local assumptions and optimizations that do not hold for the ecosystem and essentially because of ACL reasons

LDP creates a BIAS in the stored data? e.g. data has to be grouped at a certain location in a resource?
Also the notion that LDP is not an API. It’s a meta-API; there are still infinity ways to expose knowledge through LDP. So existing work and apps get this wrong.

-> The promise of data integration instead of API integration is not satisfied? - This was a point we came up with, however this can be (kinda) solved in the tooling used so ?
-> ...

The Mansouroriginal Solid paper already alluded to shortcomings of the LDP interface (globbing, a separate SPARQL interface for RDF data / metadata)
-> And we will make the argument / take the position that it is more fundamental, that LDP is the problem/limitation rather than the solution. We reframe by seeing one LDP API (there are multiple!) as a possible view on the Pod, which fundamentally is a KG. 

-->

    </div>
</section>

  <section id="vision" inlist="" rel="schema:hasPart" resource="#vision">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">The Solid pod as a permissioned Knowledge Graph</h2>
      <!-- Repeating the premise -->
      <p>One of the cornerstones of the Solid project remains the idea that data and applications can be separated, and through the semantics captured in the data, applications can achieve interoperability by integrating the available data without the requirement for specific APIs to give meaning to the data.
<!-- The proposed perspective !!!! -->
With this in mind, we propose the vision of Solid as a platform serving data Pods that provide sufficient views on the data <strong>available to the entity interacting with the pod</strong> that it can be organized as a permissioned knowledge graph.
<a href="">TODO:: This has to be on point! Maybe even the problem statement needs revising based on what we conclude here?</a>.</p>

      <!-- What is a permissioned knowledge graph -->
      <p>With the term <em>permissioned</em> knowledge graph, we express the concept of a knowledge graph, where the data contained in the knowledge graph is managed through permissions set over the data.
A permissioned knowledge graph implies that all data</p>

      <p class="comment" data-author="RD">This part still needs a good amount of work. This defintion needs to be on point, and a good explanation is required</p>

      <p>Note that while we use the term <em>permissioned</em> knowledge graph, as this leans close to the original proposition for Solid, we recognize that in the same way permissions are can be seen as specific implementations of policies, the concept of a permissioned knowledge graph serves as a base for more dynamic means of managing access to the Solid pod knowledge graph such as policies.</p>

      <!-- Make the point that Solid as LDP emulates a permissioned knowledge graph, but leads to getting stuck on certain points -> problem statement -->
      <p>In our proposed definition, the current landscape of Solid as a platform serving data pods that provide a Linked Data platform interface as a view on its internal data satisfies this perspective</p>

      <!-- Make the point that interfaces can be thought of as independent building blocks for management of data, permissions, ... -->
      <p>In the context of viewing pods as permissioned knowledge graphs that allow for mutliple interfaces, the specifications used to provide the functionality required for the Pods on the Solid platform to operate can be seen as building blocks for the Solid ecosystem. 
In this sense, we can view the existing specifications for Web Access Controls (WAC) <a href="">TODO::cite</a> and Access Control Policies (ACP) <a href="">TODO::cite</a> as two building blocks for managing permissions in the Solid ecosystem.
Similarly, the existing LDP implementation is can be seen as an available building block that fit in the proposed perspective as an interface to manage data on a data pod.
In this context, interfaces that serve as building blocks in the Solid ecosystem should be developed to be minimally interdependent to facilitate combining multiple different interfaces.</p>

      <!-- 


### Permissioned Knowledge Graphs
With the goal in mind of separating the data and applications, we propose the perspective of Solid as a permissioned knowledge graph.

Note that where permissioned knowledge graph, we understand a knowledge graph that can assign permissions for any data quads contained in the knowledge graph. We see the permissions set here as a proxy for policy-based authorization for data, where policies can dynamically describe permissions over data [TODO:: redo this]().


in our perspective is a Knowledge Graph where any collection of data can be grouped under a specific set of user permissions or policies.


### API integration
A consequence of an ecosystem where knowledge graphs can be exposed over the Web over multiple interfaces, is that this brings us back to the problem of interface-integration.

For this perspective to work, we must strive to transition from an ecosystem of API integration towards an ecosystem of data integration.

We argue that the use of Linked Data Platform as an organizational structure for data on a Solid pod relies too much on applications creating localized assumptions and optimizations for the structuring of their data that do not hold for the ecosystem, leading to applications requiring to do API integration on top of these structures, where semantics of the data may encoded and lost in this structuring instead of the data itself.

Where assumptions are currently contained in the API used to organize the data on a data pod, we need to move these assumptions to the data and explicitly encode them into the semantics of the data.

In the perspective as a pod being a permissioned Knowledge Graph that can be exposed over a multitude of APIs, we argue that exposing data over well-defined APIs can alleviate API integration problems.
[TODO:: HOWW???]()



### Interface building blocks

In this context, we can view the current state of Solid as pods that expose their internal knowledge graph over building blocks for authorization (WAC / ACP), data management and querying (LDP) and authentication (Solid-OIDC).
In this context, interface building blocks in the ecosystem should try to be minimally interdependent, to promote reuse over multiple interfaces for other components of Solid.

As a practical example, where the original paper advertised SPARQL as a possible interface to optimize querying on top of the Linked Data Platform data management layer <span class="references">\[<a href="#ref-2">2</a>\]</span>, we propose that a SPARQL endpoint may serve as a querying and data management interface on top of the knowledge graph, requiring new building blocks to be researched for authorization over such an interface.




-------------------

With this work, we propose the view of Solid as being data and application independent. 

With this work, we argue that it is not per se the interface of Linked Data Platform that is the cause of issues, but the notion that a Solid pod must adhere to the notion of being an online data space that organizes data as resources over a Linked Data Platform interface.
We pose that the assumptions described above that stem from the use of this organizational structure and the limitations it poses on the data it stores.

We propose the vision of Solid as a platform serving data pods that organize data as a Knowledge Graph <span class="references">\[<a href="#ref-5">5</a>\]</span> <span class="references">\[<a href="#ref-6">6</a>\]</span>.

A network of Solid pods can be seen as a decentralized knowledge graph. 

If a pod can be seen as a Knowledge graph, exposing the contained knowledge can take many forms, as knowledge graphs traditionally have supported multiple interfaces to add, manage and query data [TODO::sources](). 

Say something about integrating interfaces for authorization, data management and querying as building blocks in the ecosystem.

In this vision, a pod can be considered a permissioned, hybrid Knowledge graph that can be accessed through various Web APIs.

 -->

      <!-- 
The Solid paper already alluded to shortcomings of the LDP interface (globbing, a separate SPARQL interface for RDF data / metadata)
-> And we will make the argument / take the position that it is more fundamental, that LDP is the problem/limitation rather than the solution. We reframe by seeing one LDP API (there are multiple!) as a possible view on the Pod, which fundamentally is a KG

-->

      <!-- 

In the original paper for Solid, there was alluded on exposing all data over a SPARQL endpoint

Wat is solid?
- is het een set van protocols?
- is het een concept geimplementeerd met een set protocols?


Solutions can be found through:

extensions to the LDP interface:
- in spec 
- out of spec client managed?
- out of spec client sided?




### Authorization

- Resources are a straightforward way of combining data triples for authorization purposes.
- autorization systems can be adapted to work on a triple basis OR
- other ways of combining triples in resources can be used that do not include LDP biases (slash semantics)
 -->

    </div>
</section>

  <section id="comparison" inlist="" rel="schema:hasPart" resource="#comparison">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Comparison</h2>
      <p>In this section, we examine how the the proposed perspective influences the technological requirements for the Solid ecosystem, from the viewpoints of storage, publication and query.</p>

      <p class="comment" data-author="RD">Are these three viewpoints still the most relevant?</p>

      <p>The comparison consists of a hypothetical application that stores its event data on the user Solid pod.
We make the comparison between the current state of the Solid ecosystem where the LDP interface is used to organize the data, with a scenario where the Pod knowledge is directly exposed over a SPARQL endpoint.
For the comparison, we assume the stored events to consist of a timestamp, a type, and a message.</p>

      <h3 id="the-linked-data-platform-interface">The Linked Data Platform interface</h3>
      <!-- divide the data in resources -->
      <p>In the case the application that needs to write its event data to a pod where LDP is the only interface to manage data, the application first needs to distribute the data it wants to write to the pod into separate resources that will be put on the pod (note these are technically not yet resources but collections of data to be published as resources on the Solid pod). In the case of events or other objects with a logical structure, the application developers will most likely prefer to take the approach of creating separate resource for each event. 
An alternative approach could be to bundle events in a single resource, but this comes at the cost of the granularity over which permissions can be assigned to events.</p>

      <!-- finding place to write the data -->
      <p>With the data distributed into several resources, the application now wants to store them on a Solid pod.
If the application does not have access to a location on the pod, it can start up a negotiation protocol to receive access to write data to the pod that is not in scope of this work.
With access given to the pod, the application now needs to organize the created resources of data into a structure that can be written over the LDP interface of data pod.</p>

      <!-- organize the resources on the pod -->
      <p>A first option would be for the application to just write all resources to a single container the application has access to, together with all other application data. Publishing all data as resources in a single container means the application is not making any assumptions as to the organization of data. However, in this case, the LDP interface does nothing to aid the application in finding previously stored data. The application either has to keep an internal state of where resources were stored, or check the available resources on the pod until a match is found.</p>

      <!-- need for structuring -->
      <p>Because of this, it is more interesting for applications to create structure in their data, as through these structures, applications can more easily retrieve written data. To create this structure, the application can create an <code>events</code> folder in their allocated data space, and store all event resources in this <code>&lt;storage_space&gt;/events/</code> location. Now any time the applications wants to read or write events, it can make the local assumption that all event related data <em>written by the application</em> will be stored at this <code>events</code> folder.</p>

      <!-- need for optimizations -->
      <p>But as the application expects to be working with large amounts of event data, it might decide that further optimizations are required. For this purpose, it might want to choose to organize the data according to one of its properties such as the timestamp of the event, or the type of the event. In this case, an event might be stored as the following resource on the pod: <code>&lt;storage_space&gt;/events/2022/01/01/event1.ttl</code>.</p>

      <!-- conclusion -->
      <p>We see that the events stored by the application are now structured according to the assumptions and optimizations done by the application.</p>

      <p>From a <strong>storage</strong> standpoint, the event data is stored on the file system of the POD server as a file, or may be stored in a graph database where the data is tagged as part of that resource, so that the resource can be reconstructed in its entirety.</p>

      <p>From a <strong>publication</strong> standpoint, all data of an event is published as a resource over the POD LDP interface on a location that is tied to the application-specific organization of data.</p>

      <p>From a <strong>query</strong> standpoint, the data must first be discovered on the pod, after which it can be queried directly through dereferencing the relevant resources or by an abstraction on the client that provides access to the data over another interface.
Data discovery can happen using brute-force retrieval of all available resources, but is limited by the permissions an agent has over what can be viewed on the data pod. Additionally, public resources in private containers may lead to brute-force methods not discovering these resources and not including the contained data in their results.
Options external to the LDP interface such as the Type Indexing system <a href="">TODO:: refer</a> and Shape Trees <a href="">TODO:: refer</a> can optimize this process, but as of yet are not mandatory in the specifications and are not required to be managed by the server <a href="">TODO:: is this true for shape trees??</a>.</p>

      <h4 id="model-based-interfaces-sparql">model-based interfaces (SPARQL)</h4>
      <p>In the case of model-based interfaces, we take the well known example of the SPARQL endpoint <a href="">TODO::cite</a>.
A Solid pod exposing its internal knowledge graph over a SPARQL endpoint interface does not impose any requirements on structuring of the data <a href="">TODO:: this is correct right??</a>.</p>

      <!-- No need for data division and organization -->
      <p>An agent interacting with the data stored on a Solid pod over a SPARQL endpoint interface, 
the application is not required to change the organizational structure of the data. 
Any data graph used by the application can be written to the Solid pod without requiring additional data organization.</p>

      <!-- No requirement for optimizations -->
      <p>As the application storing its data on a Solid Pod cannot really organize the data being written in specific ways over the SPARQL endpoint interface, it can only change the data graph that the application is working with.
This means that any optimizations or local assumptions that the application wants to make over its data, must be encoded in the semantics of the data in the internal knowledge graph itself.</p>

      <!-- Need for additional interfaces for dereferencing -->

      <!-- Use of hypermedia links -->

      <!-- conclusion -->
      <p>We see that the events stored by the application are now structured according to the assumptions and optimizations done by the application.</p>

      <p>From a <strong>storage</strong> standpoint, the event data is stored on the file system of the POD server as a file, or may be stored in a graph database where the data is tagged as part of that resource, so that the resource can be reconstructed in its entirety.</p>

      <p>From a <strong>publication</strong> standpoint, all data of an event is published as a resource over the POD LDP interface on a location that is tied to the application-specific organization of data.</p>

      <p>From a <strong>query</strong> standpoint, the data must first be discovered on the pod, after which it can be queried directly through dereferencing the relevant resources or by an abstraction on the client that provides access to the data over another interface.
Data discovery can happen using brute-force retrieval of all available resources, but is limited by the permissions an agent has over what can be viewed on the data pod. Additionally, public resources in private containers may lead to brute-force methods not discovering these resources and not including the contained data in their results.
Options external to the LDP interface such as the Type Indexing system <a href="">TODO:: refer</a> and Shape Trees <a href="">TODO:: refer</a> can optimize this process, but as of yet are not mandatory in the specifications and are not required to be managed by the server <a href="">TODO:: is this true for shape trees??</a>.</p>

      <p>From a <strong>storage</strong> standpoint, the event data is stored in a graph-based database on the Pod server.</p>

      <p>from a <strong>publication</strong> standpoint, multiple interfaces can be used</p>

      <p>From a <strong>query</strong> standpoint</p>

      <p class="comment" data-author="RD">TODO:: This whole section</p>

      <!-- 



### Storing events on a Pod
A first concrete example we can give is the example of storing events on a Solid pod.
Events are a wide-spread 

We will make this comparison based on the aspects of storage of the data on the pod server, the publication of the data over the Web, and querying of data over the interface.

#### Storage



#### Publication



#### Query

**queries and APIs are separate concepts**


### Comparing interfaces
A common misconception is that a server interface should be identical to the client interface [TODO::cite and word according to Ruben blog](). 
Interfaces however can be abstracted away in a proxy (A web page abstracting an SQL interface in filters), or on the client (Comunica abstracting away a TPF server as SPARQL)[TODO::cite]().

For decentralized networks of data sources such as the Solid ecosystem, these abstractions will mainly be the building blocks for applications to work with data stored on the pods.

We pose that the interface exposing the server Knowledge Graph influences the possibilities and biases for abstractions created over them.
As the Linked Data Platform allows data to be retrieved by retrieving the resources present in the containers and resources advertised by the main index [TODO:: wording??](), consequences of the interface such as public resources in private containers not being discoverable through link traversal of the LDP index will limit the abstractions that can be created over the interface.

Where initiatives such as the Solid Interoperability Specification [TODO::cite]() work to provide answers for these use-cases, they are bound to the organization of data on a pod imposed by the Linked Data Platform specification.


### Data storage comparison
Different interfaces exposing data of a knowledge graph may require different storage solutions to access the underlying data.
Note that again here building blocks providing conversions for different interfaces on specific storage mechanisms may be implemented.

#### Linked data platform interfaces
can use multiple approaches for data storage. The original Solid introduction paper [TODO::cite]() proposed a file-based backend for the storage of non-rdf resources, where rdf resources were stored in a file-based or graph-based system dependent on the optional support for SPARQL over the resources in the pod.

#### [meta-]model-based interfaces
may require more elaborate back-end support depending on the interface exposed. As interfaces such as SPARQL and TPF interfaces rely mostly on an indexed data graph storage mechanisms[TODO:: ...](), 
Support for non-rdf resources must always be taken into account, requiring some sort of organizational structure for these resources to be setup.




### Data publication comparison
The data management interface used by a Solid pod influences how the internal data is published over the Web.
The interface directs how data can be accessed, the granularity of 


#### Linked data platform interfaces
provide a resource-based data organization organized according to the Linked Data Platform specification.

- slash semantics - bias
- data discovery difficulties (type index, interop spec, ...)


#### [meta-]model-based interfaces

- quad / view?-based
- discovery through interface index (SPARQL, TPF, ...)
- non-RDF resource metadata indexing (as in original paper)
- ...



### Data querying comparison
The organizational structure of data published over the interface influences the query resolution and optimization process.
Other differences such as the granularity with which the data can be accessed influences the querying process.

#### Linked data platform interfaces
rely for querying on their data organization, or on derived interfaces to support querying requirements.
As data discovery is hindered by local assumptions made by applications in the organization of data and their shape, either knowledge about the organization of data, or brute forcing of the available resources is required to discover and retrieve data relevant to a query.
The inclusion of optional SPARQL support in the first iterations of the Solid specification [TODO::cite]() supports this.

#### [meta-]model-based interfaces
require the client to discover the exposed interface, and adopt the querying strategy accordingly. A practical example of this is the comunica querying framework, that can adapt its querying strategy according to the datasource interface <span class="references">\[<a href="#ref-7">7</a>\]</span>.
Querying performance and evaluation is dependent on the exposed interface.
Assumptions on the shape of data contained in the internal knowledge graph still provide the same challenges, but the organizational structure of data should be abstracted away for clients working with and querying the data.


### How does the framing of pods as a Knowledge Graph solve the API integration problem?

In the problem statement, we pose that Linked Data Platform is a meta-API that leads to API integration problems.
How does this solve this issue?

We first pose that API's are a means of syncing data between systems [TODO:: cite](), and data retrieval will always happen over an API (even direct retrieval implicates an API, as you know the location of the resource, etc ...) [TODO:: ...]().

The problem with enforcing Linked Data Platform as the single meta-API for Solid is that biases and  -->

      <!-- 
the APIs are just a means of syncing data between systems 
(see https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/#abstracting-away-p-4) 
-> Granted but this does not really provide the comforting words that "we will change the API-integration hell into a data-integration opportunity".

cons -> need to support multiple interfaces
pros -> used interface should not have influence on the exposed data, just on how it can be accessed, as the context remains the same? -> something like this but requires some extra thinking? -->
    </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Conclusion</h2>
      <!-- With this work, we propose perspective of Solid as ...  -->
      <p class="comment reference needed" data-author="RD">With this work, we propose the perspective of Solid as a platform serving data Pods that provide sufficient views on the data available to the entity interacting with the pod that it can be organized as a permissioned knowledge graph.</p>

      <p class="comment" data-author="RD">Be sure to adapt this to the final expression we come up with</p>

      <!-- Argue this perspective in itself does not solve the existing difficulties in interoperability  -->
      <p>The perspective proposed in this work does not in itself provide a solution for the difficulties faced for the Solid ecosystem to provide the separation of applications and data.
But we argue that this perspective is necessary for solutions to be created that promote longevity in their approach to achieve this separation and provide an ecosystem centered around the concept of data-integration.</p>

      <!-- Make case that LDP limits the innovation surface for Solid -->
      <p>We argue that the current choice for the Linked Data Platform specification as the de facto interface for managing with data in a Solid pod requires developers to make localized assumptions and optimizations in applications in cases where the imposed structure of the interface do not match the real world.
<!-- Where LDP can promote assumptions over the API -> we need to get these assumptions in the data as semantics  -->
Where the LDP interface can promote the custom of encoding assumptions about data in the bundling of data in resources and the structuring of these resources on the pod, as if they are coding against a file system, we pose that this goes contrary to the development of an interactive ecosystem of applications and data.
Using the proposed perspective, we hope to provide a framework that may lead to improvements in how these assumptions can be encoded in the semantics of the stored data.</p>

      <p class="comment" data-author="RD">Maybe this should be worded a bit different?</p>

      <!-- The perspective continues from the current state of solid and is completely compatible with the current state -->
      <p>We note that the proposed perspective does not go against the current state and use of Solid, but must be seen as a zoomed out attempt at providing a good framing for the issues that are being encountered working on the ecosystem.
<!-- The goal of this work is to provide a perspective on the identity of Solid that can help in future work on the topic -->
We do not propose any specific takeaway as to which interfaces may provide solutions for faced difficulties, but we hope that the provided perspective can focus the discussions on the topic in a frame that allows for a way to tackle difficulties in a way that is not restricted by a specific interface on the data.</p>

      <!-- -------------------

The insights proposed in this work are crucial to eliminate 
the dependency of Solid apps on concrete APIs.
Local assumptions about the shape and organization of data creating localized APIs for applications over the Linked Data Platform interface exposed by Solid data pods provide local optimizations for data discovery, querying performance and more, but hurt the ecosystem as a whole, as assumptions and biases in the organization and discovery of data are not shared across the ecosystem.

The framing of Solid pods as a Knowledge Graph exposed over a multitude of APIs contrary to a data source organized using the Linked Data Platform specification enables us to think more about 
with the goal of reducing local assumptions and optimizations in apps for reasons of longevity. The API over which data is exposed over the Web is a means to an end, and should not define the platform. -->

    </div>
</section>

  <section id="acknowledgements" inlist="" rel="schema:hasPart" resource="#acknowledgements">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Acknowledgements</h2>

      <p>Supported by SolidLab Vlaanderen (Flemisch Goverment, EWI and RRF project V023/10)</p>
    </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://solid.mit.edu/" typeof="schema:CreativeWork"><a href="https://solid.mit.edu/">https:/​/​solid.mit.edu/</a></dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#sambra_solid_nodate" typeof="schema:Article">Sambra, A.V., Mansour, E., Hawke, S., Zereba, M., Greco, N., Ghanem, A., Zagidulin, D., Aboulnaga, A., Berners-Lee, T.: Solid: A Platform for Decentralized Social Applications Based on Linked Data. 16</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#BERNERS-LEE_HENDLER_LASSILA_2001" typeof="schema:Article">BERNERS-LEE, T.I.M., HENDLER, J.A.M.E.S., LASSILA, O.R.A.: THE SEMANTIC WEB. Scientific American. 284, 34–43 (2001).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://dspace.mit.edu/handle/1721.1/91861" typeof="schema:Thesis">Presbrey, J.(J.W.: Linked data platform for web applications. <a href="https://dspace.mit.edu/handle/1721.1/91861">https:/​/​dspace.mit.edu/handle/1721.1/91861</a> (2014).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-37439-6_1" typeof="schema:Chapter">Fensel, D., Şimşek, U., Angele, K., Huaman, E., Kärle, E., Panasiuk, O., Toma, I., Umbrich, J., Wahler, A.: Introduction: What Is a Knowledge Graph? In: Fensel, D., Şimşek, U., Angele, K., Huaman, E., Kärle, E., Panasiuk, O., Toma, I., Umbrich, J., and Wahler, A. (eds.) Knowledge Graphs: Methodology, Tools and Selected Use Cases. pp. 1–10. Springer International Publishing, Cham (2020). doi:10.1007/978-3-030-37439-6_1</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/" typeof="schema:CreativeWork">Verborgh, R.: Reflections of knowledge. <a href="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/">https:/​/​ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/</a> (2021).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-00668-6_15" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: A Modular SPARQL Query Engine for the Web. In: Vrandečić, D., Bontcheva, K., Suárez-Figueroa, M.C., Presutti, V., Celino, I., Sabou, M., Kaffee, L.-A., and Simperl, E. (eds.) The Semantic Web – ISWC 2018. pp. 239–255. Springer International Publishing, Cham (2018). doi:10.1007/978-3-030-00668-6_15</dd>
</dl>
</section>
</footer>



</body>
</html>
