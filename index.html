<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">What&#39;s in a Pod?</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="What's in a Pod?">
  <meta name="citation_author" content="Ruben Dedecker" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2022/08/23" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="whats-in-a-pod">What’s in a Pod?</h1>

  <h2 id="understanding-solids-decentralized-knowledge-graphs">Understanding Solid’s decentralized knowledge graphs</h2>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://rubendedecker.be/" typeof="foaf:Person schema:Person" resource="https://rubendedecker.be/#me">Ruben Dedecker</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
Department of Electronics and Information Systems,
Ghent University – imec</li>
  </ul>

  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Solid ecosystem provides specifications
for the publication and consumption of decentralized permissioned data,
stored across multiple locations called <q>Pods</q>.
<!-- Need         -->
A disconnect exists between the practical notion of a Pod
and the protocol that provides access to its data,
creating confusion as to what exactly a Pod is
and how it relates to the technical specifications.
To reinstate clarity,
<!-- Task         -->
we examined possible interpretations of the technological underpinnings,
and compared them from the viewpoints of
storage, publication and query.
<!-- Object       -->
First, this article details
the current understanding of Pods as a collection of Linked Data documents.
Second,
we propose a wider definition
in which a Solid Pod is fundamentally a knowledge graph,
which can be accessed through various Web APIs
that act as views in a database sense.
<!-- Findings     -->
We argue that the latter zoomed-out perspective
enables accessing and querying knowledge within Pods
in more flexible and sustainable ways.
<!-- Conclusion   -->
These insights are crucial to reduce
the dependency of Solid apps on concrete APIs
and local assumptions about the shape and organization of data
and the resulting performance.
<!-- Perspectives -->
The suggested broader perspective supports Solid with
evolving into a heterogeneous but interoperable ecosystem
that accommodates for a multitude of data access patterns.</p>

    </div>
</section>

</header>

<main>
  <section>
<div datatype="rdf:HTML" property="schema:description">

      <hr />
      <hr />
      <hr />
      <hr />

      <p><strong>OVERVIEW</strong></p>

      <hr />
      <hr />
      <hr />
      <hr />

      <p><strong>intro</strong></p>

      <ul>
        <li>Solid proposed as a data platform using the open Linked Data Platform spec to organize data.
          <ul>
            <li>people equate the Solid pod to the LDP interface</li>
            <li>give a working definition</li>
            <li>is there an agreed upon definition that is authoritive?</li>
          </ul>
        </li>
        <li>We see however that the use of the Linked Data Platform specification leads to a lot of ASSUMPTIONS in the organization of data on the pod.</li>
        <li>This leads to difficulties in discovery, querying, semantics? and interoperability of data.</li>
        <li>
          <p>In this paper, we propose the vision of Solid as a platform of data pods exposing an internal Knowledge Graph supporting multiple interfaces (such as LDP and SPARQL) over their internal Knowledge Graph.</p>
        </li>
        <li>Promise of Solid: Data and App independent</li>
      </ul>

      <p><strong>Problem statement</strong></p>

      <ul>
        <li>
          <p>We see that the definition of a pod gets equated to the LDP interface</p>
        </li>
        <li>We see the use of the Linked Data Platform spec leads to localized ASSUMPTIONS in the organization of data on the pod by applications</li>
        <li></li>
        <li>
          <p>Granularity is resource based through LDP.</p>
        </li>
        <li>Hierarchical nature of the LDP spec (same as filesystem) leads to semantics in the data location through slash semantics
          <ul>
            <li>e.g. original paper using slash semantics for event storage based on date</li>
            <li>Leads to semantic context being stored in the data path (not machine readable)</li>
            <li>WHAT DOES MEAN -&gt; consequence
              <ul>
                <li>model situations that cannot be captured like this</li>
                <li>example of meta-API</li>
              </ul>
            </li>
            <li>LDP has constraints, real world data modelling has constraints, these may be orthogonal in situations and not match</li>
            <li><strong>point 1: mismatch between hierarchy and real world</strong></li>
            <li>putting the meaning in the data removes mismatch between semantics and data. semantics should be in the data and in the organizational structure</li>
          </ul>
        </li>
        <li>Containers and resources lead to data stored separately (e.g. digita storing data of different applications in different containers, idem as e.g. program files on the filesystem.)
          <ul>
            <li>This leads to data separation, and implicit context being attributed to storage location (data stored at <code>/apps/solidbook/</code> is data from the <code>solidbook</code> app.)</li>
            <li>With the advantage of facilitating permission management for applications</li>
            <li><strong>point 2: Data hierarchy is created by applications in contrast to separation of app and data</strong></li>
          </ul>
        </li>
        <li><strong>point 3: semantics encoded in things that are not data</strong>
          <ul>
            <li>care of ordering of points</li>
          </ul>
        </li>
        <li>LDP leads to local assumptions and optimizations for applications(, at the cost of interoperability?).
          <ul>
            <li>We can see this clearly in the Inrupt Developer Libraries for Solid, where the developer interface only provides functionality to retrieve data for which you know both the location and the used schema, with almost no regard for data discovery.</li>
          </ul>
        </li>
        <li><strong>Coupling with permission</strong>
          <ul>
            <li>permissioning coupled with container structure</li>
            <li>one true hierarchy that matches with permissioning is the assumption - does not always hold</li>
            <li>organization is ordered according to applications -&gt; applications define your permissions indirectly</li>
          </ul>
        </li>
      </ul>

      <hr />

      <ul>
        <li>solid about <strong>splitting data and apps</strong></li>
        <li>key: <strong>semantics in the data</strong></li>
        <li>now; ldp <strong>mismatch hierarchy and real world</strong></li>
        <li>then: <strong>hierarchy misused</strong> by applications to model things how they like - <strong>semantics outside of data</strong></li>
        <li>even worse: applications make <strong>local optimizations</strong> and assumptions creating ecosystem thats not interoperable anymore</li>
        <li>permissions: as permissions are tied to hierarchy, <strong>indirectly leads to applications defining your permissions.</strong></li>
      </ul>

      <hr />

      <ul>
        <li><strong>What were we trying to do</strong>
          <ul>
            <li>create permissioned knowledge graph
              <ul>
                <li>all of the above is captured in this concept</li>
                <li>issues come from the emulation of permissioned knowledge graph through LDP and not from the concept of permissioned knowledge graph</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

      <p>cause::</p>

      <ul>
        <li>LDP is a not a real API (in the same way that a file system is not a real API). It is a meta-api that allows an infinite ways to organize data.
          <ul>
            <li>In its base form, combined with access controls, it provides little to no functionality for data interoperability.</li>
            <li>The goal of Linked Data is data integration, where LDP actually still requires a lot of api-integration through assumptions or agreements between applications on certain data organizations (e.g. solid chat in mashlib, …).</li>
            <li><strong>Ldp imposes constrainsts - leaves degrees of freedom that is used to create additional semantics not captured in the data</strong></li>
          </ul>
        </li>
      </ul>

      <p><strong>Perspective</strong></p>

      <ul>
        <li>In this paper, we propose the perspective of Solid being data and app independent.</li>
        <li>Where currently often used perspective of Solid IS LDP, or Solid is …</li>
        <li>
          <p>We propose the perspective of a Solid pod as permissioned knowledge graph …</p>
        </li>
        <li>
          <p>if we keep seeing Solid pods as containers and resources we’re going to get stuck</p>
        </li>
        <li>Make sure it stays exemplifying -&gt;
          <ul>
            <li>Make point of SPARQL endpoint over the document proposed in paper</li>
            <li>With this view, we can see the SPARQL endpoint as exposing the RAW data, without requiring the document organization of LDP</li>
            <li>Dont go to deep - more of an example</li>
          </ul>
        </li>
        <li>OH no - what about the API’s =&gt; Oh no, what about all the local assumptions
          <ul>
            <li>Solid marks transition from API based integration to data based integration</li>
            <li>the assumptions are now in the API -&gt; we need to move the assumptions to the data and try to make them specific using semantics -&gt; this is a strong conclusion</li>
          </ul>
        </li>
        <li><strong>permissions are a proxy for policies / parameters</strong>
          <ul>
            <li>permissioned -&gt; we can zoom this out to parameterized / policy based</li>
          </ul>
        </li>
      </ul>

      <hr />

      <ul>
        <li>This as a contrast to the LDP-organization currently used, that organizes data in resources.</li>
        <li>these pods can expose their internal KG over a multitude of interfaces
          <ul>
            <li>wont this reduce interoperability through not supporting other interfaces?</li>
            <li>argue currently little to no interoperability without prior agreements on data shape and organization over LDP.</li>
            <li>original paper includes support for SPARQL for querying -&gt; this goes along with this vision.</li>
          </ul>
        </li>
        <li>APIs could be built through modular building blocks as is the case now (LDP, WAC/ACP, Solid-OIDC)
          <ul>
            <li>building blocks should be built with AS LITTLE INTER-DEPENDENCY AS POSSIBLE</li>
          </ul>
        </li>
        <li>The current implementation of Solid is a specific implementation of this vision that can be expanded upon.
          <ul>
            <li>As the SPARQL in the original paper does + how Jeroen handles it in the architecture paper, more links???</li>
          </ul>
        </li>
      </ul>

      <p><strong>Comparison</strong></p>

      <ul>
        <li>In this step, we compare the frameworks of thinking about Solid as a collection of resources exposed over Linked Data Platform, compared to Solid as a Knowledge Graph exposed over a [meta-]model-based interfaces (SPARQL, TPF, …).</li>
      </ul>

      <hr />

      <ul>
        <li><strong>What do we need? -&gt; A good example</strong>
          <ul>
            <li>compare 2 cases -&gt; precise examples
              <ul>
                <li>store address book in classic solid with LDP
                  <ul>
                    <li>if you store this LDP API in file system -&gt; straightforward</li>
                    <li>SPARQL endpoint -&gt; encode document in which this is stored</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>make point that query and API are separate!</strong>
          <ul>
            <li>suggestion of SPARQL endpoint per resource</li>
            <li>bring some clarity to this point</li>
          </ul>
        </li>
        <li>Storage
          <ul>
            <li>LDP
              <ul>
                <li>File-based and/or SPARQL-based backend</li>
              </ul>
            </li>
            <li>KG
              <ul>
                <li>pretty much same. Graph database for RDF, file based for non-RDF</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Publication
          <ul>
            <li>LDP
              <ul>
                <li>resource based</li>
                <li>slash semantics - bias</li>
                <li>data discovery difficulties (type index, interop spec, …)</li>
                <li>…</li>
              </ul>
            </li>
            <li>KG
              <ul>
                <li>quad / view?-based</li>
                <li>discovery through interface index (SPARQL, TPF, …)</li>
                <li>non-RDF resource metadata indexing (as in original paper)</li>
                <li>…</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Query
          <ul>
            <li>LDP
              <ul>
                <li>Data organization assumptions (how and where data stored)</li>
                <li>Data shape assumptions (what predicates, …)</li>
              </ul>
            </li>
            <li>KG
              <ul>
                <li>Interface negotiation (SPARQL, TPF, LDP, …)
                  <ul>
                    <li>Interface-specific implementations and optimizations</li>
                  </ul>
                </li>
                <li>Data shape assumptions (what predicates, …)</li>
                <li></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

      <p><strong>Conclusion</strong></p>

      <ul>
        <li>
          <p>Viewing a pod as a KG does not solve issues in itself, but provides a thinking framework to think about and solve issues focused more on the data than the interface.</p>
        </li>
        <li>
          <p>queries and APIs are separate - important to bring this point forward again</p>
        </li>
        <li>
          <p>LDP gives us only a limited innovation surfaces</p>
        </li>
        <li>
          <p>API based integration to data integration</p>
        </li>
        <li>
          <p>(not for here) resources are not well defined units of data. You can see the whole pod as a single resource (all rdf data)</p>
        </li>
      </ul>

      <hr />

      <ul>
        <li>It does however provide a more robust framework to think about solving challenges for decentralized data pods</li>
        <li>It enables more functionality and optimization though more workload-specific interfaces (cfr databases over a filesystem)</li>
        <li>This vision builds upon the current implementation without any discrediting of work done, but with the hope of building on the existing specifications and ideas to solve even more challenges.</li>
      </ul>

      <hr />
      <hr />
      <hr />
      <hr />

      <p><strong>OVERVIEW END</strong></p>

      <hr />
      <hr />
      <hr />
      <hr />

    </div>
</section>

  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Introduction</h2>
      <p>The current Web has come a long way from it’s initial vision.
Originally designed as a decentralized network of computers serving and retrieving data form and to the network, 
data has become more centralized as data traffic converged to centralized platforms that span billions of accounts.</p>

      <p>As a response to this, the Solid project was introduced by sir. Tim Berners Lee, the inventor of the original Web<a href="">TODO:: this is a weak intro</a>.
Solid was presented as a data platform enabling a decentralized Web of personal online datastores(PODs)
by building on existing web standards <a href="">TODO:: cite</a>.
The Linked Data Platform specification was chosen as a way to organize data on a data pod.
<a href="">TODO:: write some good flavour text above. Maybe yoink some from other papers</a></p>

      <p>We see that in the current state, the specification has started to define the platform, where the use of Linked Data Platform to organize data on a data pod leads to local assumptions being made in applications on how data organization in a data pod should be handled.</p>

      <p>In this work, we propose the vision of Solid as a platform of data pods containing an internal Knowledge Graph that can expose this knowledge graph over a multitude of interfaces.</p>

      <p>In <a href="#problem_statement">Section 2</a>, we define the problem with viewing a data pod as a Linked Data Platform API, and how this leads to biases of the interface being transferred to the data stored.
With <a href="#vision">Section 3</a>, we propose the merit of defining a data pod as a knowledge graph that can be exposed over a multitude of APIs.
<a href="#comparison">Section 4</a> includes a high-level comparison over the interpretations of a data pod, after which a conclusion is formulated in <a href="#conclusion">Section 5</a>.</p>

    </div>
</section>

  <section id="problem_statement" inlist="" rel="schema:hasPart" resource="#problem_statement">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Problem statement</h2>
      <p>With the goal of facilitating the integration of data for applications over the Web, 
the Solid protocol defines a set of open standards that can be used to interact with the data stored on a pod <a href="">TODO::cite</a>.
The protocol to read, write and organize data on Solid data pods is (an adapted version of) the Linked Data Platform specification <span class="references">[<a href="#ref-1">1</a>]</span>. 
The Linked Data Platform specification defines a set of rules for operations on and interactions with resources over the Web using HTTP(S).
It defines the concepts of containers and resources to organize data, which similarly to a file system create a hierarchic storage structure of containers (~directories) containing resources (~files) and other containers.
These resources can be non-RDF resources such as images, word documents, … as well as RDF resources, which are a collection of RDF data formatted according to an RDF data format.
<a href="">TODO:: maybe I should have a separate section introducing the concepts of LDP, Solid, …?</a>
The Solid protocol adopts an adapted version of this specification, including HTTP PUT for direct control over resource naming and location.</p>

      <h3 id="linked-data-platform">Linked Data Platform</h3>

      <h4 id="data-granularity">Data granularity</h4>
      <p>A consequence of using this specification is that data must be organized in resources, as this is the only form of data that can be managed using Linked Data Platform. This requires applications to make local assumptions as to what constitutes a resource and how application data should be distributed over resources in a data pod. As resources are the only interface, other data structures such as databases are impossible, and must be emulated on the client side over the resources exposed by the LDP interface.</p>

      <h4 id="organizational-semantics">Organizational semantics</h4>
      <p>As resources are stored in a hierarchical way due to the nature of the Linked Data Platform specification, the organization of data in a hierarchical order may carry implicit semantics in the organization of resources on a data pod. We see this return in the original paper<span class="references">[<a href="#ref-2">2</a>]</span>, where the example is given of an application storing events using a URI path structure based on dates (i.e., /2016/05/01/event1). The problem with these localized assumptions is they do not hold for the ecosystem, and form an application specific API built on Linked Data Platform <a href="">TODO:: what more?</a>.</p>

      <h4 id="hierarchical-bias">Hierarchical bias</h4>
      <p>The hierarchical organization of data on a pod also leads to data separation between applications. We see this with e.g. Digita <a href="">TODO::source</a> providing a separate container for each app, in the same way that the <code>Program Files</code> folder provides a location for applications to store data. While this mitigates issues of overwriting data, and adds implicit context to data based on its location (at least for the application managing a certain data space), this comes at the cost of data discovery and integration <a href="">TODO:: what more?</a>.</p>

      <h4 id="ldp-as-a-meta-api">LDP as a meta-API</h4>
      <p>We argue that the Linked Data Platform interface is not an API, but a meta-API that can organize data in an infinite amount of ways. In the current environment, applications are forced to make local assumptions, and create application-specific API’s on the Solid data pods through localized assumptions that do not hold for the ecosystem. This comes at the cost of data discovery and interoperability with different applications that do not share the same assumptions.</p>

      <h3 id="api-integration-versus-data-integration">API-integration versus data-integration</h3>

      <p>As the goal for interoperability of online data spaces is to move from the paradigm of API integration to mode data integration centered approaches of data publishing, we see that Linked Data Platform in it’s current state creates API integration issues for applications through localized assumptions in data organization and format / shape <a href="">TODO:: maybe also make the point of format / shape integration a bit more</a>.</p>

      <p>The original paper proposes a solution for data discovery through providing a SPARQL interface that runs on top of the data organized in the Linked Data Platform, where every resource serves as its own SPARQL endpoint (https://github.com/nodeSolidServer/node-solid-server/issues/962) which has since been removed from the spec -&gt; this was no solution after all so maybe this should be casually mentioned as a sidenote?</p>

      <!-- 

As a consequence of these decisions, using the Linked Data Platform interface, reading this contact data requires the knowledge of where the data is stored, and the formatting in which the data is stored to work with the data.

As a consequence of using LDP for the organization of resources on a data pod, the main discovery mechanism over this interface is link traversal through the LDP interface.
This is however a limited approach, as in case an agent tries to retrieve information stored in a public resource at at `&lt;pod_uri&gt;/private/public`, where the parent container `&lt;pod_uri&gt;/private/` is set to be private, the resource cannot be discovered unless the exact URI can be discovered through another means.

In their "extensions to LDP" part of the paper, they propose the "PUT" extension to LDP, with the example of a calendar application
that uses a URI path structure based on dates (i.e., /2016/05/01/event1). A PUT request is to create a new resource called event1,
as well as the missing month (i.e., 05) and day (i.e., 01) containers under /2016.
Here we see again the reliance on the LDP bias (using the slash semantics as semantic information over the stored data instead of explicitly tagging the data with the information), that leads to assumptions being required to discover the data.

The complex data retrieval proposed through SPARQL mentions that optionally a SPARQL endpoint can be provided on a data pod, enabling more complex data queries from a pod, where rdf-resources and metadata for non-rdf resources can be exposed over the interface.
This is to address shortcomings in the LDP interface of not being able to express complex data retrieval operations such as filtering and aggregation. Also proposed here is that pod servers may be responsible for evaluating queries spanning multiple pods by forwarding requests for additional data to other pod servers.

In their related work, it states:
Solid has a strong focus on decoupling data from
applications and in addition ensuring that applications have a simple, generic
and well defined way to access the data stored in the users’ pods.




In Section 5, the paper presents the POD Management system. It defines that pods use LDP to organize data in containers that group resources with every resource and container having their own URI. A pod server should support 
- LDP
- patching (N3-patch, former SPARQL update)
- access control lists (ACL), potentially to be updated to access control policies (ACP).
- live updates
- optionally SPARQL

They advise storage mechanisms for RDF data to use triple stores to facilitate querying.

From all this information, we infer that their approach is focused on data discovery and querying happening mainly over a SPARQL interface that has a full index of all data that is available to the agent querying over the pod and can fulfill these requirements on the server side.



### LDP as an API
Additionally, we also argue that LDP is not an API: it’s a meta-API. 
There are still an infinite amount of ways to expose knowledge over LDP. 
We notice existing work and apps get this wrong[TODO::cite]().


Because of this, we see that the promise of Solid moving the equation from API-integration to data-integration does not hold.
As LDP cannot be viewed as a simple API, the problem of integrating different API's to access data from different sources 
has been translated into requiring knowledge of different writing / storage methods to access data stored on different pods by different applications,
leading to a different kind of API integration, without providing the data-integration that was promised. -->

      <!-- 


------------------------------------------------------------------




A disconnect exists between the practical notion of a Pod and the protocol that provides access to its data, creating confusion as to what exactly a Pod is and how it relates to the technical specifications.

- LDP creates biases in the stored data?
- data integration issues w LDP?


- spec updates evolved the understanding of Solid pods
- the technical specifications put limits on the way data can be interacted with
- to attain the goal of replacing the API integration with data integration, have to work around the limitations of LDP or build alternative interfaces on top.




The current state of LDP makes us think of pods as collections of Linked Data Documents

We see a fundamental mismatch with usage.
We see different apps making local assumptions and optimizations that do not hold for the ecosystem and essentially because of ACL reasons

LDP creates a BIAS in the stored data? e.g. data has to be grouped at a certain location in a resource?
Also the notion that LDP is not an API. It’s a meta-API; there are still infinity ways to expose knowledge through LDP. So existing work and apps get this wrong.

-> The promise of data integration instead of API integration is not satisfied? - This was a point we came up with, however this can be (kinda) solved in the tooling used so ?
-> ...

The Mansouroriginal Solid paper already alluded to shortcomings of the LDP interface (globbing, a separate SPARQL interface for RDF data / metadata)
-> And we will make the argument / take the position that it is more fundamental, that LDP is the problem/limitation rather than the solution. We reframe by seeing one LDP API (there are multiple!) as a possible view on the Pod, which fundamentally is a KG. 

-->

    </div>
</section>

  <section id="vision" inlist="" rel="schema:hasPart" resource="#vision">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">The Solid pod as a Knowledge Graph</h2>

      <!-- 
The Solid paper already alluded to shortcomings of the LDP interface (globbing, a separate SPARQL interface for RDF data / metadata)
-> And we will make the argument / take the position that it is more fundamental, that LDP is the problem/limitation rather than the solution. We reframe by seeing one LDP API (there are multiple!) as a possible view on the Pod, which fundamentally is a KG

 -->

      <p>With this work, we argue that it is not per se the interface of Linked Data Platform that is the cause of issues, but the notion that a Solid pod must adhere to the notion of being an online data space that organizes data as resources over a Linked Data Platform interface.
We pose that the assumptions described above that stem from the use of this organizational structure and the limitations it poses on the data it stores.</p>

      <p>We propose the vision of Solid as a platform serving data pods that organize data as a Knowledge Graph <span class="references">[<a href="#ref-3">3</a>]</span> <span class="references">[<a href="#ref-4">4</a>]</span>.</p>

      <p>A network of Solid pods can be seen as a decentralized knowledge graph.</p>

      <p>If a pod can be seen as a Knowledge graph, exposing the contained knowledge can take many forms, as knowledge graphs traditionally have supported multiple interfaces to add, manage and query data <a href="">TODO::sources</a>.</p>

      <p>Say something about integrating interfaces for authorization, data management and querying as building blocks in the ecosystem.</p>

      <p>In this vision, a pod can be considered a permissioned, hybrid Knowledge graph that can be accessed through various Web APIs.
### Interface building blocks</p>

      <p>In this context, we can view the current state of Solid as pods that expose their internal knowledge graph over building blocks for authorization (WAC / ACP), data management and querying (LDP) and authentication (Solid-OIDC).
In this context, interface building blocks in the ecosystem should try to be minimally interdependent, to promote reuse over multiple interfaces for other components of Solid.</p>

      <p>As a practical example, where the original paper advertised SPARQL as a possible interface to optimize querying on top of the Linked Data Platform data management layer <span class="references">[<a href="#ref-2">2</a>]</span>, we propose that a SPARQL endpoint may serve as a querying and data management interface on top of the knowledge graph, requiring new building blocks to be researched for authorization over such an interface.</p>

      <!-- 

In the original paper for Solid, there was alluded on exposing all data over a SPARQL endpoint

Wat is solid?
- is het een set van protocols?
- is het een concept geimplementeerd met een set protocols?


Solutions can be found through:

extensions to the LDP interface:
- in spec 
- out of spec client managed?
- out of spec client sided?




### Authorization

- Resources are a straightforward way of combining data triples for authorization purposes.
- autorization systems can be adapted to work on a triple basis OR
- other ways of combining triples in resources can be used that do not include LDP biases (slash semantics)
 -->

    </div>
</section>

  <section id="comparison" inlist="" rel="schema:hasPart" resource="#comparison">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Comparison</h2>

      <p>In this section, we examine possible interpretations of the technological underpinnings, and compared them from the viewpoints of storage, publication and query.</p>

      <h3 id="comparing-interfaces">Comparing interfaces</h3>
      <p>A common misconception is that a server interface should be identical to the client interface <a href="">TODO::cite and word according to Ruben blog</a>. 
Interfaces however can be abstracted away in a proxy (A web page abstracting an SQL interface in filters), or on the client (Comunica abstracting away a TPF server as SPARQL)<a href="">TODO::cite</a>.</p>

      <p>For decentralized networks of data sources such as the Solid ecosystem, these abstractions will mainly be the building blocks for applications to work with data stored on the pods.</p>

      <p>We pose that the interface exposing the server Knowledge Graph influences the possibilities and biases for abstractions created over them.
As the Linked Data Platform allows data to be retrieved by retrieving the resources present in the containers and resources advertised by the main index <a href="">TODO:: wording??</a>, consequences of the interface such as public resources in private containers not being discoverable through link traversal of the LDP index will limit the abstractions that can be created over the interface.</p>

      <p>Where initiatives such as the Solid Interoperability Specification <a href="">TODO::cite</a> work to provide answers for these use-cases, they are bound to the organization of data on a pod imposed by the Linked Data Platform specification.</p>

      <h3 id="data-storage-comparison">Data storage comparison</h3>
      <p>Different interfaces exposing data of a knowledge graph may require different storage solutions to access the underlying data.
Note that again here building blocks providing conversions for different interfaces on specific storage mechanisms may be implemented.</p>

      <h4 id="linked-data-platform-interfaces">Linked data platform interfaces</h4>
      <p>can use multiple approaches for data storage. The original Solid introduction paper <a href="">TODO::cite</a> proposed a file-based backend for the storage of non-rdf resources, where rdf resources were stored in a file-based or graph-based system dependent on the optional support for SPARQL over the resources in the pod.</p>

      <h4 id="meta-model-based-interfaces">[meta-]model-based interfaces</h4>
      <p>may require more elaborate back-end support depending on the interface exposed. As interfaces such as SPARQL and TPF interfaces rely mostly on an indexed data graph storage mechanisms<a href="">TODO:: …</a>, 
Support for non-rdf resources must always be taken into account, requiring some sort of organizational structure for these resources to be setup.</p>

      <h3 id="data-publication-comparison">Data publication comparison</h3>
      <p>The data management interface used by a Solid pod influences how the internal data is published over the Web.
The interface directs how data can be accessed, the granularity of</p>

      <h4 id="linked-data-platform-interfaces-1">Linked data platform interfaces</h4>
      <p>provide a resource-based data organization organized according to the Linked Data Platform specification.</p>

      <ul>
        <li>slash semantics - bias</li>
        <li>data discovery difficulties (type index, interop spec, …)</li>
      </ul>

      <h4 id="meta-model-based-interfaces-1">[meta-]model-based interfaces</h4>

      <ul>
        <li>quad / view?-based</li>
        <li>discovery through interface index (SPARQL, TPF, …)</li>
        <li>non-RDF resource metadata indexing (as in original paper)</li>
        <li>…</li>
      </ul>

      <h3 id="data-querying-comparison">Data querying comparison</h3>
      <p>The organizational structure of data published over the interface influences the query resolution and optimization process.
Other differences such as the granularity with which the data can be accessed influences the querying process.</p>

      <h4 id="linked-data-platform-interfaces-2">Linked data platform interfaces</h4>
      <p>rely for querying on their data organization, or on derived interfaces to support querying requirements.
As data discovery is hindered by local assumptions made by applications in the organization of data and their shape, either knowledge about the organization of data, or brute forcing of the available resources is required to discover and retrieve data relevant to a query.
The inclusion of optional SPARQL support in the first iterations of the Solid specification <a href="">TODO::cite</a> supports this.</p>

      <h4 id="meta-model-based-interfaces-2">[meta-]model-based interfaces</h4>
      <p>require the client to discover the exposed interface, and adopt the querying strategy accordingly. A practical example of this is the comunica querying framework, that can adapt its querying strategy according to the datasource interface <span class="references">[<a href="#ref-5">5</a>]</span>.
Querying performance and evaluation is dependent on the exposed interface.
Assumptions on the shape of data contained in the internal knowledge graph still provide the same challenges, but the organizational structure of data should be abstracted away for clients working with and querying the data.</p>

      <h3 id="how-does-the-framing-of-pods-as-a-knowledge-graph-solve-the-api-integration-problem">How does the framing of pods as a Knowledge Graph solve the API integration problem?</h3>

      <p>In the problem statement, we pose that Linked Data Platform is a meta-API that leads to API integration problems.
How does this solve this issue?</p>

      <p>We first pose that API’s are a means of syncing data between systems <a href="">TODO:: cite</a>, and data retrieval will always happen over an API (even direct retrieval implicates an API, as you know the location of the resource, etc …) <a href="">TODO:: …</a>.</p>

      <p>The problem with enforcing Linked Data Platform as the single meta-API for Solid is that biases and</p>

      <!-- 
the APIs are just a means of syncing data between systems 
(see https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/#abstracting-away-p-4) 
-> Granted but this does not really provide the comforting words that "we will change the API-integration hell into a data-integration opportunity".

cons -> need to support multiple interfaces
pros -> used interface should not have influence on the exposed data, just on how it can be accessed, as the context remains the same? -> something like this but requires some extra thinking? -->
    </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Conclusion</h2>
      <p>The insights proposed in this work are crucial to eliminate 
the dependency of Solid apps on concrete APIs.
Local assumptions about the shape and organization of data creating localized APIs for applications over the Linked Data Platform interface exposed by Solid data pods provide local optimizations for data discovery, querying performance and more, but hurt the ecosystem as a whole, as assumptions and biases in the organization and discovery of data are not shared across the ecosystem.</p>

      <p>The framing of Solid pods as a Knowledge Graph exposed over a multitude of APIs contrary to a data source organized using the Linked Data Platform specification enables us to think more about 
with the goal of reducing local assumptions and optimizations in apps for reasons of longevity. The API over which data is exposed over the Web is a means to an end, and should not define the platform.</p>

      <p>With this work, we do not propose any specific takeaway as to which interfaces may optimize the current problems of data shape and organization when building applications on top of Solid, but want to provide a framework with which these problems can be tackled in a way that is not restricted to only what the LDP interface allows.</p>

    </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dspace.mit.edu/handle/1721.1/91861" typeof="schema:Thesis">Presbrey, J.(J.W.: Linked data platform for web applications. <a href="https://dspace.mit.edu/handle/1721.1/91861">https:/​/​dspace.mit.edu/handle/1721.1/91861</a> (2014).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#sambra_solid_nodate" typeof="schema:Article">Sambra, A.V., Mansour, E., Hawke, S., Zereba, M., Greco, N., Ghanem, A., Zagidulin, D., Aboulnaga, A., Berners-Lee, T.: Solid: A Platform for Decentralized Social Applications Based on Linked Data. 16</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-37439-6_1" typeof="schema:Chapter">Fensel, D., Şimşek, U., Angele, K., Huaman, E., Kärle, E., Panasiuk, O., Toma, I., Umbrich, J., Wahler, A.: Introduction: What Is a Knowledge Graph? In: Fensel, D., Şimşek, U., Angele, K., Huaman, E., Kärle, E., Panasiuk, O., Toma, I., Umbrich, J., and Wahler, A. (eds.) Knowledge Graphs: Methodology, Tools and Selected Use Cases. pp. 1–10. Springer International Publishing, Cham (2020). doi:10.1007/978-3-030-37439-6_1</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/" typeof="schema:CreativeWork">Verborgh, R.: Reflections of knowledge. <a href="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/">https:/​/​ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/</a> (2021).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-00668-6_15" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: A Modular SPARQL Query Engine for the Web. In: Vrandečić, D., Bontcheva, K., Suárez-Figueroa, M.C., Presutti, V., Celino, I., Sabou, M., Kaffee, L.-A., and Simperl, E. (eds.) The Semantic Web – ISWC 2018. pp. 239–255. Springer International Publishing, Cham (2018). doi:10.1007/978-3-030-00668-6_15</dd>
</dl>
</section>
</footer>



</body>
</html>
