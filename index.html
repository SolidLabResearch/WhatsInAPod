<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">What&#39;s in a Pod?</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="What's in a Pod?">
  <meta name="citation_author" content="Ruben Dedecker" />
  <meta name="citation_author" content="Wout Slabbinck" />
  <meta name="citation_author" content="Jesse Wright" />
  <meta name="citation_author" content="Patrick Hochstenbach" />
  <meta name="citation_author" content="Pieter Colpaert" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2022/10/17" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="whats-in-a-pod">What’s in a Pod?</h1>

  <h2 id="aknowledge-graph-interpretation-for-the-solid-ecosystem">A knowledge graph interpretation for the Solid ecosystem</h2>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://rubendedecker.be/" typeof="foaf:Person schema:Person" resource="https://pod.rubendedecker.be/profile/card#me">Ruben Dedecker</a>¹</li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/woutslabbinck/" typeof="foaf:Person schema:Person" resource="https://woslabbi.pod.knows.idlab.ugent.be/profile/card#me">Wout Slabbinck</a>¹</li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/jeswr" typeof="foaf:Person schema:Person" resource="https://id.inrupt.com/jeswr">Jesse Wright</a>²</li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://patrickhochstenbach.net" typeof="foaf:Person schema:Person" resource="https://hochstenbach.solidcommunity.net/profile/card#me">Patrick Hochstenbach</a>¹</li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://pietercolpaert.be/" typeof="foaf:Person schema:Person" resource="https://pietercolpaert.be/#me">Pieter Colpaert</a>¹</li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a>¹</li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">¹IDLab,
Department of Electronics and Information Systems,
Ghent University – imec</li>
    <li id="anu">²Australian National University,
College of Engineering &amp; Computer Science</li>
  </ul>

  <section class="context">
    <h2 id="in-reply-to">In reply to</h2>
    <ul>
      <li><a href="http://www.wikicfp.com/cfp/servlet/event.showcfp?eventid=159481" rel="as:inReplyTo">QuWeDa 2022 call for papers</a></li>
    </ul>
  </section>

</header>

<div id="content">

<section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Solid vision aims to make data independent of applications
through technical specifications,
which detail how to publish and consume permissioned data
across multiple autonomous locations called <q>pods</q>.
<!-- Need         -->
The current document-centric interpretation of Solid,
wherein a pod is solely a hierarchy of Linked Data documents,
cannot fully realize this envisaged independence.
Applications are left to define their own APIs
within the Solid Protocol,
which leads to fundamental interoperability problems
and the need for associated workarounds.
The broader longterm vision for Solid is confounded
with the concrete HTTP interface to pods today,
leading to a narrower solution space to address these core issues.
<!-- Task         -->
We examine the mismatch between the vision
and the prevalent document-centric interpretation,
and propose a reconciliatory graph-centric interpretation
wherein a pod is fundamentally a knowledge graph.
<!-- Object       -->
In this article,
we contrast the existing and proposed interpretations
in terms of how they support the Solid vision.
We argue that the graph-centric interpretation
can improve pod access through different Web APIs
that act as views into the knowledge graph.
<!-- Findings     -->
We show that the latter interpretation
provides improved opportunities for
storage, publication, and querying of decentralized data
in more flexible and sustainable ways.
<!-- Conclusion   -->
These insights are crucial to reduce
the dependency of Solid apps on implicit API semantics
and local assumptions about the shape and organization of data
and the resulting performance.
<!-- Perspectives -->
The suggested broader interpretation can guide Solid
through its evolution into a heterogeneous yet interoperable ecosystem
that supports the diverging read/write data access patterns of different use cases.</p>

    </div>
</section>


<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">The Solid vision of data interoperability and control</h2>
        <!-- Introduction of Solid -->
        <p>Data privacy and control have lost ground on today’s Web.
User-generated data is stored in centralized data silos,
in which people have neither the control nor the knowledge to manage how their data is being used <span class="references">[<a href="#ref-1">1</a>]</span>.
As a response to this, the <em>Solid</em> project was created with the aim of revitalizing the Web <span class="references">[<a href="#ref-2">2</a>, <a href="#ref-3">3</a>]</span>.
Where the current system of centralized data silos create an ecosystem of limited integration, availability and innovation,
Solid brings a course correction for the Web.
Based on the <em>separation of data and applications</em>,
the vision defines an ecosystem that facilitates the integration of data in different applications, while keeping people in direct control of their data.</p>

        <!-- the Solid pod -->
        <p>To this end,
Solid introduces the concept of a <em>pod</em>
as an online data space for an individual to control and manage their data on the Web.
Together, these pods form a decentralized Solid ecosystem,
from which applications can directly integrate data from a person’s Solid pod,
after receiving their permission.
This contrasts with current Web applications, where
this data first had to be collected in a centralized location,
after which the platform-specific API had to be integrated,
where all the while user control is at the mercy of the platforms maintaining the data.</p>

        <!-- key for achieving requirement: capture semantics in the data -->
        <p>A precondition to the separation of data and application
is the capture of semantic information in the data itself,
such that it can be reused in different contexts.
Semantics allow applications to interpret data without 
requiring specific knowledge encoded in the API over which the data is retrieved.
A key driver is the use of the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">Resource Description Framework (RDF)</a> <span class="references">[<a href="#ref-4">4</a>]</span>,
which provides an infrastructure for the capture of this semantic information.
This again contrasts with current Web APIs,
where data is served in formats that require additional semantics to be captured in the documentation of the API.
By shifting the focus from the API to the data,
the Solid ecosystem aims to transition the Web
from an ecosystem of API integration towards
an ecosystem of data integration <span class="references">[<a href="#ref-5">5</a>]</span>.</p>

        <!-- The problem: no API-independence -->
        <p>Unfortunately, we observe a significant gap between theory and practice:
current Solid apps do not succeed in API-independent reuse of data
across use cases.
Rather than only relying on the data and its semantics,
apps resort to implicit knowledge
about how this data is structured across documents in a pod’s API.
Furthermore,
different use cases impose conflicting requirements
on that structure in order to satisfy their constraints.
As such,
application developer struggle to make sustainable decisions
on how to structure data for reuse,
since their individual choices impact the interoperability of the entire ecosystem.</p>

        <!-- Article purpose -->
        <p>In this article,
we identify the root cause of this interoperability problem
as the mismatch between Solid’s current single hierarchical API
and the modeling requirements of real-world use cases.
We describe the properties of this document-centric interpretation on a Pod,
and introduce a graph-centric interpretation
that can bridge differences between use cases.
We compare both interpretations,
explain the consequences for concrete Solid implementations,
and argue why we consider the graph-centric interpretation
a more sustainable candidate to realize the Solid vision
of data and application independence under control of the user.</p>

      </div>
</section>

  <section id="use-cases" inlist="" rel="schema:hasPart" resource="#use-cases">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Motivating use cases</h2>
        <p>In order to pinpoint the concrete differences between interpretations,
we introduce two small use cases that we will carry throughout the paper.</p>

        <h3 id="contacts-use-case">Contacts use case</h3>
        <p>The <em>contacts</em> use case is a rather trivial example,
but we introduce it to show that even very simple use cases
can expose issues in the interpretation of a Pod.
The implication is thus that,
if a certain interpretation cannot adequately handle the contacts case,
then it will likely also break for more complex cases.
The case is as follows:</p>

        <ul>
          <li>The data consists of a set of <strong>contacts</strong>,
each of which have associated attributes such as
name, address, email, phone number, date of birth.</li>
          <li>An <strong>address book</strong> app provides read and write access
to each attribute of a contact,
and allows to create new contacts.</li>
          <li>A <strong>birthday app</strong> shows daily reminders of contacts with upcoming birthdays,
and it allows editing birthdays and adding new ones.</li>
        </ul>

        <h3 id="medical-use-case">Medical use case</h3>
        <p>The <em>medical</em> use case is conceptually simple,
but it involves highly sensitive data.
Its purpose is to demonstrate that issues identified in the <em>contacts</em> use case
easily generalize to more core complex data and real-world problems.
In this use case, the user is a patient storing the following data:</p>

        <ul>
          <li>A set of medical records reflecting <strong>blood test results</strong>,
with each record containing various vitamin levels
as well as HIV status results.</li>
          <li>A set of <strong>heart rate and blood pressure measurements</strong>,
captured by the user’s wearable device.</li>
        </ul>

      </div>
</section>

  <section id="definitions" inlist="" rel="schema:hasPart" resource="#definitions">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Preliminary definitions</h2>

        <p>Before describing the interpretations of a Solid pod,
we start with a couple of definitions that we will use as building blocks
throughout the article.</p>

        <ul>
          <li>We consider a <dfn id="dfn-protocol">protocol</dfn> to be
a generic set of rules for data transmission between systems.
            <ul>
              <li>The <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://www.rfc-editor.org/rfc/rfc9110"><dfn id="dfn-http">HyperText Transfer Protocol (HTTP)</dfn></a> <span class="references">[<a href="#ref-6">6</a>]</span>
structures the exchange of data between a server and a client
as resources identified by a URI.</li>
              <li>The <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/TR/ldp/"><dfn id="dfn-ldp">Linked Data Platform (LDP)</dfn></a> <span class="references">[<a href="#ref-7">7</a>]</span>
constrains HTTP with interaction rules
for recursive containers of RDF and non-RDF documents.</li>
              <li>The <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solidproject.org/TR/2021/protocol-20211217"><dfn id="dfn-solid-protocol">Solid Protocol</dfn></a> <span class="references">[<a href="#ref-8">8</a>]</span>
constrains HTTP with authentication and authorization,
and with interaction rules
for recursive containers of RDF and non-RDF documents
(inspired by LDP).</li>
            </ul>
          </li>
          <li>A <dfn id="dfn-web-api">Web API</dfn> is a specific structuring of resources
on top of HTTP (or a specialization thereof, such as the Solid Protocol).</li>
          <li><dfn id="dfn-authentication">Authentication</dfn>
means identifying the agent making a request to a Web API.
            <ul>
              <li>The <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solidproject.org/TR/2022/oidc-20220328"><dfn id="dfn-webid">WebID</dfn></a> <span class="references">[<a href="#ref-9">9</a>]</span>
is an HTTP URL that identifies an agent.
When dereferenced,
it leads to a <dfn id="dfn-profile-document">profile document</dfn>
describing various agent details.</li>
              <li><a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solidproject.org/TR/2022/oidc-20220328"><dfn id="dfn-solid-oidc">Solid-OIDC</dfn></a> <span class="references">[<a href="#ref-9">9</a>]</span>
establishes some authoritative identification of an agent by a specific WebID.</li>
            </ul>
          </li>
          <li><dfn id="dfn-authorization">Authorization</dfn>
means determining to what extent an agent is allowed
to perform a certain request to a Web API.
            <ul>
              <li><a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solid.github.io/web-access-control-spec/"><dfn id="dfn-wac">Web Access Control (WAC)</dfn></a> <span class="references">[<a href="#ref-10">10</a>]</span>
is an Access Control List (ACL) mechanism
that allows assigning inheritable permissions to documents and containers
through so-called <em>ACL documents</em>.</li>
              <li><a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solid.github.io/authorization-panel/acp-specification/"><dfn id="dfn-acp">Access Control Policies (ACP)</dfn></a> <span class="references">[<a href="#ref-11">11</a>]</span>
is a policy-based mechanism
that allows assigning inheritable permissions to documents and containers
through so-called <em>Access Control Resources (ACR)</em>.</li>
            </ul>
          </li>
        </ul>

        <p>Let us exemplify some of these definitions through our use cases:</p>

        <ul>
          <li>An HTTP interface at <code>https:/​/​sasha.pod/</code> implements the Solid Protocol
when its containers and documents follow the interaction rules,
and when it correctly authenticates users
using their WebID,
and applies authorization to each resource.</li>
          <li>A Web API within <code>https:/​/​sasha.pod/</code> structures documents in containers.
            <ul>
              <li>Contacts are stored in <code>https:/​/​sasha.pod/people/</code>
as individual documents:
                <ul>
                  <li><code>https:/​/​sasha.pod/people/sasha.ttl</code></li>
                  <li><code>https:/​/​sasha.pod/people/lucian.ttl</code></li>
                </ul>
              </li>
              <li>Medical records are stored in <code>https:/​/​sasha.pod/private/acme-hospital/</code>
by date, such as:
                <ul>
                  <li><code>https:/​/​sasha.pod/private/acme-hospital/2022/10/15/test-results.ttl</code></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The WebID <code>https:/​/​sasha.pod/people/sasha#me</code> identifies a person named Sasha.</li>
          <li>The agent identified by <code>https:/​/​sasha.pod/people/sasha#me</code>
is allowed to access all documents on <code>https:/​/​sasha.pod/</code>.</li>
        </ul>

      </div>
</section>

  <section id="document-centric" inlist="" rel="schema:hasPart" resource="#document-centric">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Document-centric interpretation of a pod</h2>
        <p>This section discusses the currently prevalent interpretation of a pod,
which is <em>document</em>-centric.</p>

        <h3 id="document-centric-definition">Definition</h3>
        <p>As described in <a href="#definitions">Section 3</a>,
the Solid Protocol models interactions with data
as recursive containers with RDF and non-RDF documents.
When a server offers this protocol,
clients of this server can define a Web API
by creating containers and documents within those containers.</p>

        <p>The document-centric interpretation assumes
that the structure and contents of the Web API,
which the pod exposes through the Solid Protocol,
<em>is</em> the pod in its entirety.
Within this interpretation,
the complete state of the pod is equivalent
to the single Web API through which it is available;
the <em>source of truth</em> is solely that specific Web API.
That brings us to the following definition:</p>

        <p><em>In the document-centric interpretation,
each <dfn id="dfn-document-centric">Solid pod</dfn>
is a single specific hierarchical structure of containers and documents
exposed through the Solid Protocol,
where data and access control rules are stored
in specific RDF and non-RDF documents within that hierarchy.</em></p>

        <h3 id="example">Example</h3>

        <p>For example,
a Solid pod would be fully defined
by the following hierarchy and the contents of its documents:</p>

        <ul>
          <li>container <code>https:/​/​sasha.pod/</code>
            <ul>
              <li>RDF document <code>.acl</code> <em>(for access control)</em></li>
              <li>container <code>people/</code>
                <ul>
                  <li>RDF document <code>.acl</code> <em>(for access control)</em></li>
                  <li>RDF document <code>amal.ttl</code></li>
                  <li>RDF document <code>lucian.ttl</code></li>
                  <li>…</li>
                </ul>
              </li>
              <li>container <code>private/</code>
                <ul>
                  <li>RDF document <code>.acl</code> <em>(for access control)</em></li>
                  <li>container <code>medical-records/</code>
                    <ul>
                      <li>non-RDF document <code>2022-09-15.pdf</code></li>
                      <li>non-RDF document <code>2022-10-15.pdf</code></li>
                      <li>…</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>…</li>
            </ul>
          </li>
        </ul>

        <p>In the above example,
the access control document <code>https:/​/​sasha.pod/private/.acl</code>
could contain WAC rules
such that only the agent <code>https:/​/​sasha.pod/people/sasha#me</code>
is allowed to access the container <code>https:/​/​sasha.pod/private/</code>
and below.</p>

        <h3 id="practical-usage">Practical usage</h3>
        <p>The above document-centric definition of a pod
leaves several degrees of freedom
as to how the pod is structured
and how the resulting structure is interpreted.
We now describe how today’s Solid apps
fill those degrees of freedom in practice.</p>

        <h4 id="document-centric-api">Structure of the main Web API</h4>
        <p>Importantly,
the current <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solidproject.org/TR/">Solid technical reports</a> <span class="references">[<a href="#ref-12">12</a>]</span>
do not impose any specific container structure onto a pod
beyond the presence of a root container <code>/</code>.
Therefore, <em>the</em> Solid Web API does not exist;
only the Solid Protocol to create an API for each pod.
Some past <a href="https://github.com/solid/solid-spec/blob/master/recommendations-server.md">suggestions</a>
are nonetheless present as defaults
(such as <code>/profile/</code>, <code>/inbox/</code>, and <code>/settings/</code> containers)
in certain server implementations.
Since these are not standardized across the ecosystem,
their presence is not enforced by the server,
and as such cannot be relied upon.</p>

        <p>As a consequence,
client-side applications have to define their own (sub-)API
within the URL space available through the Solid Protocol,
by defining a certain container structure
and data distribution across documents within this structure.
Regarding container structure,
we observe two kinds of behavior:</p>

        <ul>
          <li>Some apps use <strong>hard-coded paths</strong>
to certain containers (e.g., <code>/contacts/</code>)
or documents (e.g., <code>/profile/card</code>).</li>
          <li>Some apps use <strong>link traversal</strong>,
which means they find the URLs of documents and containers
by following links from the user’s WebID profile document
and/or via <a property="schema:citation http://purl.org/spar/cito/citesAsExample" href="https://solid.github.io/type-indexes/">another index</a> <span class="references">[<a href="#ref-13">13</a>]</span>.</li>
        </ul>

        <p>We also observe <em>hybrid behavior</em>,
for instance where an initial path is obtained via traversal
(e.g., <code>/private/medical/</code>),
and deeper relative paths are hardcoded
(e.g., <code>/private/medical/2022/10/</code>).
In particular,
link traversal is bootstrapped via hardcoded paths:
if no link exists to the certain kind of data,
then a specific document is created at a hardcoded path
and then linked from a profile or index for future usage.</p>

        <h4 id="document-centric-aspects">Aspects of RDF document boundaries</h4>
        <p>From the way current apps organize data in RDF documents,
we can observe the meaning they ascribe to such a document.
Noting that Solid typically uses RDF 1.0 documents
(so only triples, and not quads as in RDF 1.1),
we consider the occurrence of an RDF triple in a document
to carry meaning with regard to the following aspects:</p>

        <ul>
          <li><em>(implicit)</em> <strong>Context</strong>:
the occurrence of certain triples within the same document
often implies that they are somehow interrelated,
and that these triples somehow relate to the document.
This topical relation is sometimes visible within certain triples,
whose subject (e.g., <code>https:/​/​sasha.pod/people/sasha#me</code>)
defines a URL fragment (e.g., <code>#me</code>)
on the document identifier (e.g., <code>https:/​/​sasha.pod/people/sasha</code>).</li>
          <li><em>(explicit)</em> <strong>Policy</strong>:
both the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solid.github.io/web-access-control-spec/">WAC</a> <span class="references">[<a href="#ref-10">10</a>]</span>
and the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://solid.github.io/authorization-panel/acp-specification/">ACP</a> <span class="references">[<a href="#ref-11">11</a>]</span> specifications
assign authorizations on a document level of granularity.
Either the document can be accessed by a given agent in its entirety or not,
thus resulting in all triples within a document
sharing the same authorization rules.</li>
          <li><em>(implicit)</em> <strong>Provenance</strong>:
the document somehow captures the notion
that its triples originate from a specific source or event,
of which the document was a result.</li>
          <li><em>(implicit)</em> <strong>Trust</strong>:
the document defines a single boundary of trust for all of its triples.
For example,
a user’s profile document is typically fully trusted by the user
(because they are usually the only party with write access to it),
whereas inbox documents created by third parties
might contain triples that are not trusted.</li>
          <li><em>(implicit)</em> <strong>Performance</strong>:
the document groups together a number of triples
because it improves the performance of certain use cases.
For instance,
triples that are often used together might be in the same document,
and triples that are less needed might be in extension documents,
in order to optimize the number of HTTP requests and the used bandwidth.</li>
        </ul>

        <p>We remark that of these 5 aspects,
only the <em>policy</em> on the document is modelled explicitly.
The <em>context</em> is implicitly assumed
because triples occurring in the same place
typically were created by the same or related write operations,
and because those triples are necessarily read together by apps.
The <em>provenance</em> and <em>trust</em> are similarly derived
from implicit assumptions about a shared origin,
and the knowledge of specific policies
and thus agents that could have written to the document.
Notably,
the fact that an identifier (e.g., <code>https:/​/​sasha.pod/people/</code>)
is contained within a certain pod root container (e.g., <code>https:/​/​sasha.pod/</code>)
does encode some explicit provenance about the document and its triples
(e.g., “they were found in Sasha’s pod”),
but not necessarily about its creator or level of trust
(e.g., multiple actors might have write access to the document).
Finally,
the <em>performance</em> is typically the result of educated guesses,
but seldom the result of actual performance measurements.</p>

        <h4 id="document-centric-alternative-apis">Alternative Web APIs to the pod</h4>
        <p>Given that data under the document-centric interpretation
is structured within a specific document hierarchy
with the aforementioned explicit and implicit aspects,
several applications encounter practical limitations
when the data they require happens to be structured across multiple documents.
In an attempt to address such cases,
alternative Web APIs were proposed
in addition to the main Web API on top of the Solid Protocol.</p>

        <p><a property="schema:citation http://purl.org/spar/cito/citesAsEvidence" href="http://emansour.com/research/lusail/solid_protocols.pdf">One proposal</a> <span class="references">[<a href="#ref-2">2</a>]</span>
suggests exposing a server-side <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/TR/sparql11-protocol/">SPARQL endpoint</a> <span class="references">[<a href="#ref-14">14</a>]</span>
over all RDF data in a pod,
enabling fully server-side <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="http://www.w3.org/TR/sparql11-query/">SPARQL query</a> <span class="references">[<a href="#ref-15">15</a>]</span> processing.
<a property="schema:citation http://purl.org/spar/cito/citesAsEvidence" href="https://docs.inrupt.com/ess/latest/query/qpf-endpoint/">Another proposal</a> <span class="references">[<a href="#ref-16">16</a>]</span>
suggests to expose this data through a read-only Quad Pattern Fragments (QPF) interface,
to speed up the client-side processing of SPARQL queries
over the entire pod.
Whereas these alternative APIs can alleviate
part of the <em>context</em> and <em>performance</em> aspects of the main API,
they come with challenges to implement <em>policy</em>
and to adequately model <em>provenance</em> and <em>trust</em> in their responses.</p>

        <p>Crucially, such alternative APIs are always derived from the main API,
because it is equivalent to the pod in the document-centric interpretation.
The derived APIs thereby unavoidably inherit some of the explicit and implicit aspects
from the document-based main API.
Concretely, the direct derivation from the main API manifests itself
in the choice of the data model for the SPARQL and QPF interfaces.
The RDF 1.1 quads they expose are constructed
by loading the triples from each document,
adding as a graph component the URL of that document.
The following example quad reflects this:</p>

        <ul>
          <li>subject: <code>https:/​/​sasha.pod/people/sasha#me</code></li>
          <li>predicate: <code>https:/​/​example.org/ontology#birthDate</code></li>
          <li>object: <code>"1984-04-03"</code></li>
          <li>graph: <code>https:/​/​sasha.pod/private/medical/2022/10/15.ttl</code></li>
        </ul>

        <p>Its components signify that
there exists a triple with that specific subject, predicate, and object
in the document with URL <code>https:/​/​sasha.pod/private/medical/2022/10/15.ttl</code>.
In other words,
the document-centric interpretation of a pod considers
the birthdate statements’ occurrence in this specific document on the pod
to be an integral part of the statement itself.</p>

        <h3 id="document-centric-consequences">Consequences of the single hierarchy</h3>
        <p>In this section,
we will examine and critique the consequences
of the document-centric interpretation of a pod.
Specifically,
we study the limitations of the single hierarchy it causes (<a href="#document-centric-definition">Subsection 4.1</a>),
and the effects of the implicit semantics in its structure (<a href="#document-centric-api">Subsubsection 4.3.1</a>)
and documents (<a href="#document-centric-aspects">Subsubsection 4.3.2</a>).
While some consequences could in theory
be mitigated by alternative APIs (<a href="#document-centric-alternative-apis">Subsubsection 4.3.3</a>),
the effectiveness thereof is hindered
by the necessity of those alternatives to derive from the main API structure.</p>

        <h4 id="single-app-mismatches"> Single-app modeling mismatches</h4>
        <p>Each app needs to define a single consistent hierarchy
to serialize their data,
which does not reflect the complex nature of real-world organization.
For instance,
the address book app could organize people in categories
such as <code>/contacts/work/</code> and <code>/contacts/sports/</code>,
which leads to duplication when a person’s colleague
is also a member of their badminton team.
A similar situation occurs when we need to decide
to group health measurements by date (<code>/medical/2022/10/15.ttl</code>)
or by topical evolution over time (<code>/medical/vitamine-d-levels.ttl</code>)</p>

        <p>Hierarchical organizations are thus either
constrained by their necessity to commit to a single representation of the real world,
or in need of mechanisms to cope with the effects of data duplication or virtualization.
An alternative API circumvents some of these limitations
when it comes to reading,
although the provenance and trust of the resulting responses
are even less explicitly defined than in the main API.
Writing is still fully coupled to the destination documents in the main API,
since the quad components of each triple need to contain a specific document URL.</p>

        <h4 id="cross-app-mismatches"> Cross-app modeling mismatches</h4>
        <p>The document-centric view of the Solid Protocol
does not inherently provide interoperability,
because apps are still responsible
for determining the specific API that defines
the document and container structure they will access.
To make matters worse,
different apps and use cases can have competing interests
that lead them to prefer one API structure over another.</p>

        <p>For example,
interoperability requires the address book and birthday apps
to store their data in the same place,
for instance, the <code>/people/</code> container.
Failure to do so would result in apps not being aware of 
the others’ data being available on the pod.
However,
their preferences regarding the organization of that container vary.
The address book app,
which lets the user edit contacts one by one,
has a <em>context</em> and <em>performance</em> incentive to
place all of the attributes of a contact in a single RDF document,
leading to an organization such as:</p>

        <ul>
          <li><code>/people/work/dani.ttl</code></li>
          <li><code>/people/work/kiran.ttl</code></li>
          <li><code>/people/personal/kai.ttl</code></li>
          <li><code>/people/personal/luka.ttl</code></li>
          <li>…</li>
        </ul>

        <p>In contrast,
the birthday app aims to quickly determine
which celebrations are coming up,
probably preferring a structure more like:</p>

        <ul>
          <li><code>/people/work/birthdays.ttl</code></li>
          <li><code>/people/personal/birthdays.ttl</code></li>
        </ul>

        <p>Or possibly even:</p>

        <ul>
          <li><code>/people/birthdays/january.ttl</code></li>
          <li><code>/people/birthdays/february.ttl</code></li>
          <li>…</li>
        </ul>

        <p>Similarly,
whether medical records are organized by date
or by measurement over time,
depends on the specifics of a current use case.</p>

        <h4 id="policy-mismatches">Policy modeling mismatches</h4>
        <p>Contextual- and performance-based grouping
are trade-offs that can be overcome with compromises,
such as accepting that certain use cases will be slower than others.
Unfortunately,
the imposed grouping of multiple different aspects in the same document
can also lead to more sensitive and insurmountable conflicts
for the <em>policy</em>, <em>provenance</em>, and <em>trust</em> aspects.</p>

        <p>Since the coupling of policies to document organization
provides the only mechanism of control in the document-centric view,
some use cases with conflicting requirements
cannot effectively be realized today.
For example, assume that the address book app
indeed organizes contacts as one person per document:</p>

        <ul>
          <li><code>/people/dani.ttl</code></li>
          <li><code>/people/kiran.ttl</code></li>
          <li>…</li>
        </ul>

        <p>In that case, the birthday app would be able to read
(and needing to parse)
people’s personal details such as addresses and phone numbers,
whereas the expectation is that
it should only access names and birthdays.</p>

        <p>Insurmountable conflicts become even more apparent with the medical use case.
The results of a given blood test might be stored in a single document,
and thus have a single policy boundary associated with it.
If that test result contains both vitamin levels and an HIV status,
then the document-based access control
prevents users from only giving access to their vitamin levels.</p>

        <p>The fact that conflicting requirements between aspects
would necessitate the complexity of copies,
flags a strong limitation of any single hierarchical API.
One partial solution is to split these pieces of data into different documents,
but this results in suboptimal boundaries
for purposes of context, provenance, and trust.
Users thus find themselves torn between giving apps too much access,
or having to deal with overly granular control—in the extreme case causing situations
that necessitate managing micro-documents with only one or a handful of triples.
Whereas the degrees of freedom in the Solid Protocol
allow for any such structures,
the resulting API would be highly impractical for humans and machines alike.
Another solution involves creating and maintaining
a copy of the document with a subset of the data,
which—in addition to the overhead of managing such copies—would also
generate a different associated context, provenance, and trust,
especially if writing to such derived documents is needed.
Furthermore,
all these aspects would necessarily be reflected in any derived APIs,
which are tied to the main API’s document-based structure and boundaries.</p>

        <p>We conclude that the pod inherently contains
a <em>large amount of implicit semantics</em> in its API structure,
which hinders the realization of the data and application independence
that is paramount to the Solid vision.
Some of semantics that are supposed to be entangled with the data
are in practice assumed by the API,
the construction of which happens in an uncoordinated way over time.
The resulting spontaneous contracts are not made explicit by a single app,
nor shared across multiple apps,
meaning that interoperating apps have to be coded against each other
rather than against the data,
creating undesired inter-application coupling.</p>

      </div>
</section>

  <section id="graph-centric" inlist="" rel="schema:hasPart" resource="#graph-centric">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Graph-centric interpretation of a pod</h2>
        <p>This section introduces a new interpretation of the concept of a Solid pod,
which is <em>graph-centric</em>.</p>

        <h3 id="design-considerations">Design considerations</h3>
        <p>We start from the limitations of the document-centric pod interpretation,
which essentially assumes the Web API exposed by a pod
to be equivalent to the pod itself.
On the one hand,
we acknowledge the <em>universality</em> and <em>simplicity</em>
of document-based APIs,
and in particular of the Solid Protocol,
which offers the building blocks to construct such APIs
with the appropriate authentication and authorization.
On the other hand,
we showed concrete evidence in <a href="#document-centric-consequences">Subsection 4.4</a>
that no single such hierarchy is able to
reconcile the conflicting constraints of different use cases,
especially given that core aspects such as policies and provenance
can only be applied with a document-level granularity.</p>

        <p>So while we recognize the importance of document-based Web APIs,
we also observe that the simultaneous support for multiple use cases
clearly requires multiple perspectives into the same data,
each satisfying the constraints of particular cases.
While the creation of multiple views has been attempted for Solid pods
with SPARQL and QPF interfaces,
their direct derivation from the main API
leads them to still inherit that API’s mismatched constraints
on the modeling of policies, provenance, and trust.</p>

        <p>In other words,
aiming to derive richer views from the main pod API
is akin to using a real-world object’s <em>two-dimensional projection</em>
to derive alternate two-dimensional projections of that same object.
Because any two-dimensional projection
is inherently designed to discard information of the original,
the creation of complementary alternative projections
actually requires the object’s underlying <em>three-dimensional reality</em> instead.
The two-dimensional projection was only ever meant
as a helpful approximation of the three-dimensional object.</p>

        <p>Translating this dimensionality metaphor to the world of pods,
we conclude that today’s single hierarchical API to a pod
serves as a <em>proxy</em> for the underlying knowledge graph
formed by the union of the pod’s interlinked RDF documents—except that
this union cannot adequately be reproduced
because significant parts of its semantics are being discarded by that API.
Solid applications looking to leverage
the potential of this Linked Data knowledge graph,
will thus always be hindered by
the limitations of one arbitrarily formed document API
acting as its sole access gateway.</p>

        <h3 id="graph-centric-definition">Definition</h3>
        <p>Given the above observations within the document-centric interpretation,
we create a new interpretation
that shifts the function of a pod’s main API
from being the pod itself
to acting as <em>one of many</em> possible interfaces
to an underlying knowledge graph,
which <em>is</em> the pod.
The <em>source of truth</em> is a knowledge graph
consisting of documents as well as RDF statements,
from which multiple Web APIs can be derived.
Hence, no particular API is more prominent than any other.
We define it as follows:</p>

        <p><em>In the graph-centric interpretation,
each <dfn id="dfn-graph-centric">Solid pod</dfn>
is a hybrid, contextualized knowledge graph,
wherein “hybrid”
indicates first-class support for both documents and RDF statements,
and “contextualized”
the ability to associate each of its individual documents and statements
with metadata such as policies, provenance, and trust.</em></p>

        <h3 id="example-1">Example</h3>
        <p>For example,
the pod <code>https:/​/​sasha.pod/</code> could be a hybrid knowledge graph
consisting of:</p>

        <ul>
          <li>RDF triples expressing contact details of <code>https:/​/​sasha.pod/people/amal#me</code></li>
          <li>RDF triples expressing contact details of <code>https:/​/​sasha.pod/people/lucian#me</code></li>
          <li>a PDF document containing medical images dated 2022-09-15</li>
          <li>RDF triples representing a blood test result dated 2022-10-15</li>
          <li>…</li>
        </ul>

        <p>Examples of associated metadata within this pod are:</p>

        <ul>
          <li>The RDF triples about Amal form a shared context with specific trust and provenance.</li>
          <li>A policy states that professional contact names can be publicly readable.</li>
          <li>A policy states that contacts’ phone numbers are only visible to Sasha.</li>
          <li>The provenance of Lucian’s phone number is a specific email.</li>
          <li>We trust that the test result is unmodified and accurate,
because it is certified by a medical professional.</li>
        </ul>

        <p>Below is one possible Web API on top of this pod
that conforms to the Solid Protocol:</p>

        <ul>
          <li>container <code>https:/​/​sasha.pod/</code>
            <ul>
              <li>container <code>contacts/work/</code>
                <ul>
                  <li>RDF document <code>.acl</code> <em>(for access control)</em></li>
                  <li>RDF document <code>amal.ttl</code></li>
                  <li>RDF document <code>lucian.ttl</code></li>
                  <li>…</li>
                </ul>
              </li>
              <li>…</li>
            </ul>
          </li>
        </ul>

        <p>The same pod could simultaneously offer other Web APIs through the Solid Protocol:</p>

        <ul>
          <li>container <code>https:/​/​sasha.pod/</code>
            <ul>
              <li>container <code>people/birthdays/</code>
                <ul>
                  <li>RDF document <code>.acr</code> <em>(for access control)</em></li>
                  <li>RDF document <code>january.ttl</code></li>
                  <li>RDF document <code>february.ttl</code></li>
                  <li>…</li>
                </ul>
              </li>
              <li>…</li>
            </ul>
          </li>
        </ul>

        <p>Furthermore, the pod could have SPARQL and QPF interfaces on top of its knowledge graph,
in addition to other Web APIs.</p>

        <h3 id="graph-centric-aspects">Aspects of RDF data in the graph</h3>
        <p>Importantly,
the “hybrid” and “contexualized” qualifiers
are equally important as the “knowledge graph” term in the definition.
This means that off-the-shelf triplestores or quadstores
do not qualify as implementations of a pod.
Whereas they could possibly be used as physical storage for such a pod
(see <a href="#comparison-storage">Subsection 6.1</a>),
any implementation requires native support for documents and metadata.</p>

        <p>The ability to generate multiple Web APIs
that act as views on the data
is required functionality for the pod.
Below,
we discuss how the aspects from <a href="#document-centric-aspects">Subsubsection 4.3.2</a>
are modeled in the pod and the resulting APIs.</p>

        <ul>
          <li>
            <p><strong>Context</strong>:
Each triple or document in the pod
can be associated with multiple contexts.
For instance,
users could assign triples to specific resources in Web APIs
(“this triple is in the documents <code>/records/2022-15-10.ttl</code>
 and <code>/records/2022-15-10-summary.ttl</code>”),
or smaller ad-hoc groupings could be created
(“these triples have a topical relationship”).
An API can reflect this context
through it resource structure,
or by including explicit metadata in its response.</p>
          </li>
          <li>
            <p><strong>Policy</strong>:
Policies could be assigned to resources in a Web API
and/or to individual triples.
In case the policies are assigned to individual triples,
their inclusion in a response can be conditionally determined
by whether or not the requesting agent has access.</p>
          </li>
          <li>
            <p><strong>Provenance</strong>:
Provenance can be associated with individual triples or groups of triples,
similar to how generic context is modeled.</p>
          </li>
          <li>
            <p><strong>Trust</strong>:
Trust can be expressed either as a function of provenance,
or explicitly assigned to (groups of) triples, like context.</p>
          </li>
          <li>
            <p><strong>Performance</strong>:
The performance is no longer a function of the pod structure itself,
but rather reflected in how well a specific API
matches the access patterns of a given use case.
In other words,
performance concerns can be addressed
by defining relevant APIs on top of the underlying knowledge graph.</p>
          </li>
        </ul>

        <p>The implementation of those aspects
differs from the document-centric interpretation
in two crucial ways:</p>

        <ol>
          <li>All 5 aspects are <strong>modeled <em>explicitly</em></strong>:
 either as metadata in the knowledge graph
 that can then be reflected in an API
 (for <em>context</em>, <em>policy</em>, <em>provenance</em>, and <em>trust</em>),
 or in the definition of a specific API
 (for <em>performance</em>).</li>
          <li>Each aspect can have a <strong>different granularity</strong>.
 For instance,
 a certain group of triples could share the same provenance,
 but have different policies applied to them.</li>
        </ol>

        <h3 id="view-based-use-case-modeling">View-based use case modeling</h3>
        <p>We will now revisit how the graph-centric interpretation
addresses the mismatches of the document-centric interpretation
(<a href="#document-centric-consequences">Subsection 4.4</a>).</p>

        <h4 id="single-app-modeling"> Single-app modeling</h4>
        <p>Applications are no longer restricted to a single hierarchy
for modeling information,
because the view-based approach allows overlapping resources
without requiring copies.</p>

        <p>For example,
if a person is both a colleague and a badminton player,
their details can be available through both
the documents <code>/contacts/work/amal.ttl</code> and <code>/contacts/sports/amal.ttl</code>,
wherein
the containers <code>/contacts/work/</code> and <code>/contacts/sports/</code>
could have different policies associated with them.
From the perspective of a consumer,
neither document is more authoritative than the other,
as they are generated from the same triples in the underlying knowledge graph.
Similarly,
medical records can be organized
by both date (<code>/medical/2022/10/15.ttl</code>)
and topical evolution (<code>/medical/heart-rate-2021-2022.ttl</code>),
allowing them to have different provenance and trust.</p>

        <h4 id="cross-app-modeling"> Cross-app modeling</h4>
        <p>Every app can choose the modeling that best fit its use case,
as the same knowledge graph can be exposed through multiple Web APIs.
This allows applications to find the API that best matches its access patterns
or, conversely, the pod to define APIs based on the needs of use cases.</p>

        <p>For example,
the address book app can be built using an API
that organizes the attributes of a person in a single document,
whereas the birthday app can group all birthdays together.
That way, neither application downloads more data than necessary.
Similarly,
medical data can be grouped depending on the analyses that will be performed.
Note that exact matches of access patterns to APIs
will not always be possible nor desired;
the idea is rather to offer a couple of core APIs
that minimize overhead
across a number of use cases <span class="references">[<a href="#ref-17">17</a>]</span>.</p>

        <h4 id="permission-modeling">Permission modeling</h4>
        <p>Finally,
the granularity of resources in a given API
can be aligned with the granularity of policies,
since this granularity does not have to be shared with the other aspects.</p>

        <p>For example,
the birthday app could have a read/write API to the contacts
that does not include access to their email addresses or phone numbers.
A derived medical report could only display vitamin levels
but leave out highly sensitive information such as HIV status,
while leaving intact the provenance and trust of the original context.</p>

      </div>
</section>

  <section id="comparison" inlist="" rel="schema:hasPart" resource="#comparison">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Comparative analysis</h2>
        <p>In this section,
we compare the impact of the document- and graph-centric pod interpretations
in terms of
<a href="#comparison-storage">storage</a>,
<a href="#comparison-publication">publication</a>,
and <a href="#comparison-querying">query processing</a>.</p>

        <h3 id="comparison-storage">Storage</h3>
        <p>In a document-centric interpretation,
the underlying storage of a pod is typically managed
as a document-based system,
as evidenced by current Solid server implementations
that leverage the file system or document-oriented databases.
This preferences is explained by
the direct match of the interface to the pod;
in some ways,
the document-centric view on a pod
can be seen as a permissioned file system for the Web.
Of course,
quadstore-based storage can also be applied,
in which case the fourth element of each quad
typically indicates the document to which it belongs
(and, hence, the associated metadata such as permissions).
The benefit of the latter
is that they might enable higher performance for derived APIs,
although there is still the requirement of supporting non-RDF documents,
such as for instance images or movies.</p>

        <p>The graph-centric interpretation imposes stronger requirements
on the underlying storage.
On the one hand,
different metadata might have different granularities,
so there is no longer a natural document grouping.
On the other hand,
different selections need to be created from the raw data,
so there specific document organizations provide no universal benefit across APIs.
Consequently,
document-based storage systems are not a good technological fit.
In the long term,
native implementations of hybrid, contextualized will be a necessity.
In the medium term,
they can be emulated on top of quadstores
and <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html">RDF-star stores</a> <span class="references">[<a href="#ref-18">18</a>]</span>.
Whereas quadstores can easily associate metadata with RDF 1.0 triples,
RDF-star stores could extend this functionality to RDF 1.1
when Solid pods start using graphs to model data.</p>

        <h3 id="comparison-publication">Publication</h3>
        <div class="todo">
          <p>document-centric:</p>

          <ul>
            <li>straightforward from document store</li>
          </ul>

          <p>graph-centric:
- needs high-performance view definitions and applications</p>
        </div>

        <h3 id="comparison-querying">Querying</h3>
        <div class="todo">
          <p>document-centric:</p>

          <ul>
            <li>link-traversal-based query processing</li>
            <li>possibly aided by indexes</li>
          </ul>

          <p>graph-centric:
- LDF with Comunica, choose most appropriate interfaces
- automatically generate relevant interfaces
- just a SPARQL endpoint will not be sufficient because of federated queries</p>
        </div>

      </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusion</h2>
        <p><span class="todo">Discuss transition from RPC to REST to graph?</span></p>

        <p>Different interpretations of the Solid vision
come with different abilities to support that vision.
The dominant document-centric interpretation,
specified by the <a property="schema:citation http://purl.org/spar/cito/citesAsSourceDocument" href="https://solidproject.org/TR/2021/protocol-20211217">Solid Protocol</a> <span class="references">[<a href="#ref-8">8</a>]</span>
as an LDP derivative with per-document access control,
has the benefit of being conceptually simple
and hence developer-friendly.
However, we argue in this article that the simplicity
afforded by a hierarchical document collection
stems from shortcuts taken by applications,
which are burrowing their own ad-hoc APIs with implicit semantics
into the container meta-model.
This hinders the Solid promise of data and application independence:
while the data itself contains explicit semantics that can be interpreted by apps,
the organization of that data is such that it its storage and retrieval
necessitates out-of-band contracts between different applications,
resulting in significant app-to-app coupling
and subsequently systematic app breakage when ad-hoc APIs eventually evolve.
Furthermore, we show that the abstraction easily breaks
when apps pursue slightly conflicting goals.</p>

        <p>These issues have so far largely gone unnoticed,
because singular apps do not hit such problems,
and different apps in a small ecosystem
can still coordinate behind the scenes.
However,
an emergence of more Solid apps that need to interoperate
has increased the frequency of such conflicts.
Stopgaps that are being created to address them
unfortunately only prolong unsustainable practices,
as many issues are simply inherent to the implicit semantics within ad-hoc APIs.
Proposals typically focus on making API semantics explicit <span class="references">[<a href="#ref-19">19</a>, <a href="#ref-13">13</a>]</span>,
yet they inevitably inherit the abstraction’s mismatches.
This is why we instead suggest pushing the vision forward
by separating the semantics from the API altogether.</p>

        <p>We observe that the document-centric interpretation
seems to act as a proxy for a more fundamental concept,
namely a permissioned, hybrid knowledge graph
that accommodates data as well as documents.
Our proposed graph-centric interpretation
put this concept at the heart of each pod,
and considers document interfaces such as those that exist today
as specialized views of an underlying richer source of truth.
This affords more flexibility—and hence independence—in
how multiple apps can interact with the same graph data.
Crucially,
this also broadens the solution space
to tackle interoperability challenges.
We are no longer confined to working around inherent LDP-level problems,
but can create solutions at the knowledge graph level
and mint associated API views tailored to the needs and constraints
of specific applications and use cases.
The same app can seamlessly interact
via different read and write interfaces to a pod,
depending on what it is optimizing for.
This also opens the door for authorization
with different granularities beyond the scope of
one specific LDP interface’s document organization.
We thereby shift the understanding
from a data graph instantiated from a document organization,
to a dynamically instantiated document interface over a data graph,
paving the way for fundamentally graph-centric data management within Solid.
Through the zoomed-out perspective of the pod
as a knowledge graph exposed over Web APIs, 
we refocus on the data itself
and reframe the interfaces as means to an end.</p>

        <p>Consequences from interpretation differences are not purely conceptual or theoretical.
For instance,
current implementations of alternative access APIs to pods
are still tainted by the document-centric interpretation:
the current Quad Pattern Fragments interface
uses for its quads’ graph components
the URI where the <em>document-centric</em> API happens to expose them.
Ironically,
the server thereby imposes some of the same LDP constraints and mismatches
on the very API that is supposed to mitigate them.
This happens because the additional API is built on top of the LDP-based API,
which this interpretation considers to <em>be</em> the pod.
In a graph-centric interpretation,
the pod is instead a knowledge graph with multiple APIs as views.
Document URIs are ephemeral artifacts of one particular API
that carry no meaning in the graph,
nor in other views or apps.
Therefore,
a Quad Pattern Fragments API within the graph-centric interpretation
would never use the document URL from another API as fourth quad component.</p>

        <p>We stress that the document-centric as well as the graph-centric interpretation
are supported by the current Solid specifications,
notably the <a property="schema:citation http://purl.org/spar/cito/citesAsSourceDocument" href="https://solidproject.org/TR/2021/protocol-20211217">Solid Protocol</a> <span class="references">[<a href="#ref-8">8</a>]</span>,
which is a testament to both the orthogonality of the specification
and the vision compatibility of graph-centricity.
Specifically,
the graph-centric interpretation of the Solid vision
still embraces document-based access as a core building block for APIs.
What changes is the role played by the document hierarchy:
rather than the one absolute source of truth of a pod,
we recognize more value in seeing it as one of many views
into a much more elaborate knowledge graph,
for which APIs act as a vessel.
Therefore,
what is in a pod is essentially in the eye of the beholder:
all depends on which view offers the best fit for a specific purpose.</p>

      </div>
</section>

  <section id="acknowledgements" inlist="" rel="schema:hasPart" resource="#acknowledgements">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Acknowledgements</h2>

        <p>Supported by SolidLab Vlaanderen (Flemish Goverment, EWI and RRF project V023/10).</p>

      </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://www.w3.org/DesignIssues/CloudStorage.html" typeof="schema:CreativeWork">Berners-Lee, T.: Socially aware cloud storage. <a href="https://www.w3.org/DesignIssues/CloudStorage.html">https:/​/​www.w3.org/DesignIssues/CloudStorage.html</a> (2009).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="http://emansour.com/research/lusail/solid_protocols.pdf" typeof="schema:CreativeWork">Sambra, A.V., Mansour, E., Hawke, S., Zereba, M., Greco, N., Ghanem, A., Zagidulin, D., Aboulnaga, A., Berners-Lee, T.: Solid: A Platform for Decentralized Social Applications Based on Linked Data. <a href="http://emansour.com/research/lusail/solid_protocols.pdf">http:/​/​emansour.com/research/lusail/solid_protocols.pdf</a> (2016).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://ruben.verborgh.org/articles/redecentralizing-the-web/" typeof="schema:Chapter">Verborgh, R.: Re-decentralizing the Web, for good this time. In: Seneviratne, O. and Hendler, J. (eds.) Linking the World’s Information: A Collection of Essays on the Work of Sir Tim Berners-Lee. ACM (2022).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/" typeof="schema:CreativeWork">Cyganiak, R., Wood, D., Lanthaler, M. eds: RDF 1.1: Concepts and Abstract Syntax. World Wide Web Consortium, <a href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">https:/​/​www.w3.org/TR/2014/REC-rdf11-concepts-20140225/</a> (2014).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/" typeof="schema:CreativeWork">Verborgh, R.: Reflections of knowledge. <a href="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/">https:/​/​ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/</a> (2021).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://www.rfc-editor.org/rfc/rfc9110" typeof="schema:CreativeWork">Fielding, R.T., Nottingham, M., Reschke, J. eds: HTTP Semantics. Internet Engineering Task Force, <a href="https://www.rfc-editor.org/rfc/rfc9110">https:/​/​www.rfc-editor.org/rfc/rfc9110</a> (2022).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://www.w3.org/TR/ldp/" typeof="schema:CreativeWork">Speicher, S., Arwe, J., Malhotra, A. eds: Linked Data Platform 1.0. World Wide Web Consortium, <a href="https://www.w3.org/TR/ldp/">https:/​/​www.w3.org/TR/ldp/</a> (2015).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="https://solidproject.org/TR/2021/protocol-20211217" typeof="schema:CreativeWork">Capadisli, S., Berners-Lee, T., Verborgh, R., Kjernsmo, K. eds: Solid Protocol. <a href="https://solidproject.org/TR/2021/protocol-20211217">https:/​/​solidproject.org/TR/2021/protocol-20211217</a> (2021).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://solidproject.org/TR/2022/oidc-20220328" typeof="schema:CreativeWork">Coburn, A., elf Pavlik, Zagidulin, D. eds: Solid-OIDC. <a href="https://solidproject.org/TR/2022/oidc-20220328">https:/​/​solidproject.org/TR/2022/oidc-20220328</a> (2022).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="https://solid.github.io/web-access-control-spec/" typeof="schema:CreativeWork">Capadisli, S. ed: Web Access Control (WAC). <a href="https://solid.github.io/web-access-control-spec/">https:/​/​solid.github.io/web-access-control-spec/</a> (2022).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://solid.github.io/authorization-panel/acp-specification/" typeof="schema:CreativeWork">Bosquet, M. ed: Access Control Policy (ACP). <a href="https://solid.github.io/authorization-panel/acp-specification/">https:/​/​solid.github.io/authorization-panel/acp-specification/</a> (2022).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://solidproject.org/TR/" typeof="schema:CreativeWork">Solid Technical Reports. <a href="https://solidproject.org/TR/">https:/​/​solidproject.org/TR/</a></dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="https://solid.github.io/type-indexes/" typeof="schema:CreativeWork">Turdean, T. ed: Type Indexes. <a href="https://solid.github.io/type-indexes/">https:/​/​solid.github.io/type-indexes/</a> (2022).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="https://www.w3.org/TR/sparql11-protocol/" typeof="schema:CreativeWork">Feigenbaum, L., Williams, G.T., Clark, K.G., Torres, E.: SPARQL 1.1 Protocol. World Wide Web Consortium, <a href="https://www.w3.org/TR/sparql11-protocol/">https:/​/​www.w3.org/TR/sparql11-protocol/</a> (2013).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="http://www.w3.org/TR/sparql11-query/" typeof="schema:CreativeWork">Harris, S., Seaborne, A.: SPARQL 1.1 Query Language. World Wide Web Consortium, <a href="http://www.w3.org/TR/sparql11-query/">http:/​/​www.w3.org/TR/sparql11-query/</a> (2013).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="https://docs.inrupt.com/ess/latest/query/qpf-endpoint/" typeof="schema:CreativeWork">Query (QPF). <a href="https://docs.inrupt.com/ess/latest/query/qpf-endpoint/">https:/​/​docs.inrupt.com/ess/latest/query/qpf-endpoint/</a> (2022).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2016.03.003" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, 184–206 (2016). doi:10.1016/j.websem.2016.03.003</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html" typeof="schema:CreativeWork">Hartig, O., Champin, P.-A., Kellogg, G., Seaborne, A. eds: HTTP Semantics. <a href="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html">https:/​/​w3c.github.io/rdf-star/cg-spec/editors_draft.html</a> (2022).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="https://shapetrees.org/TR/specification/" typeof="schema:CreativeWork">Bingham, J., Prud’hommeaux, E. eds: Shape Trees Specification. <a href="https://shapetrees.org/TR/specification/">https:/​/​shapetrees.org/TR/specification/</a> (2021).</dd>
</dl>
</section>
</footer>

</div>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>



</body>
</html>
