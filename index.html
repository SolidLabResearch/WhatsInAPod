<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">What&#39;s in a Pod?</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="What's in a Pod?">
  <meta name="citation_author" content="Ruben Dedecker" />
  <meta name="citation_author" content="Wout Slabbinck" />
  <meta name="citation_author" content="Ruben Verborgh" />
  <meta name="citation_author" content="Jesse Wright" />
  <meta name="citation_author" content="Pieter Colpaert" />
  <meta name="citation_author" content="Patrick Hochstenbach" />
  
  <meta name="citation_publication_date" content="2022/09/02" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="whats-in-a-pod">What’s in a Pod?</h1>

  <h2 id="aknowledge-graph-interpretation-of-the-solid-ecosystem">A knowledge graph interpretation of the Solid ecosystem</h2>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://rubendedecker.be/" typeof="foaf:Person schema:Person" resource="https://pod.rubendedecker.be/profile/card#me">Ruben Dedecker</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="" typeof="foaf:Person schema:Person" resource="">Wout Slabbinck</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/jeswr" typeof="foaf:Person schema:Person" resource="https://id.inrupt.com/jeswr">Jesse Wright</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://pietercolpaert.be/" typeof="foaf:Person schema:Person" resource="https://pietercolpaert.be/#me">Pieter Colpaert</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://patrickhochstenbach.net" typeof="foaf:Person schema:Person" resource="https://hochstenbach.solidcommunity.net/profile/card#me">Patrick Hochstenbach</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">
      <p>IDLab,
Department of Electronics and Information Systems,
Ghent University – imec</p>
    </li>
    <li id="anu">
      <p>Australian National University,
College of Engineering &amp; Computer Science,
Canberra ACT 2601, AU</p>
    </li>
  </ul>

  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Solid vision aims to make data independent of applications
through specifications for publishing and consuming permissioned data,
which is stored decentrally across large numbers of locations called <q>Pods</q>.
<!-- Need         -->
The current interpretation of a Pod as
a collection of Linked Data documents
falls short in realizing this vision of independence,
leading to fundamental interoperability and query problems.
Furthermore,
the broader vision for Solid
is confounded with the concrete HTTP interface to Pods today,
leading to a narrower solution space for these problems.
<!-- Task         -->
We examined the mismatch between the vision
and its currently prevalent interpretation,
and constructed a wider interpretation of a Pod as a knowledge graph
that provides improved opportunities for
storage, publication, and query.
<!-- Object       -->
In this article,
we contrast the existing and proposed interpretations
in terms of how they realize the Solid vision.
We argue that a Solid Pod is fundamentally a knowledge graph,
which can be accessed through various Web APIs
that act as views in a database sense.
<!-- Findings     -->
We show that our zoomed-out interpretation
provides improved opportunities for
storage, publication and query of decentralized data
in more flexible and sustainable ways.
<!-- Conclusion   -->
These insights are crucial to reduce
the dependency of Solid apps on implicit API semantics
and local assumptions about the shape and organization of data
and the resulting performance.
<!-- Perspectives -->
The suggested broader interpretation supports Solid with
is evolution into a heterogeneous yet interoperable ecosystem
that accommodates a multitude of read/write data access patterns.</p>

    </div>
</section>

</header>

<main>
  <section id="structure-of-whats-in-a-pod---final" inlist="" rel="schema:hasPart" resource="#structure-of-whats-in-a-pod---final">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name"><strong>Structure of What’s in a pod - final</strong></h2>

      <ul>
        <li><strong>Intro: Solid envisioned ecosystem</strong>
          <ul>
            <li>problem: your data being everywhere, no control very limited interoperability</li>
            <li>Solid: a vision for a better Web</li>
            <li>ecosystem goal: control over data, interoperability over applications and data</li>
            <li>requirement: separation of apps and data</li>
            <li>key for achieving requirement: capture semantics in the data</li>
            <li>enables: data integration instead of interface integration</li>
            <li>BUT: the understanding of what a pod is varies wildly</li>
            <li>there is no authoritative definition</li>
            <li>
              <p>leads to misunderstandings that confuse the product of the Solid pod with the envisioned ecosystem.</p>
            </li>
            <li>something about data privacy and permissions / policies?</li>
          </ul>
        </li>
      </ul>

      <hr />

      <ul>
        <li><strong>A document-centric interpretation of the Solid pod</strong>
          <ul>
            <li>Solid uses an adaptation of LDP spec to interact with data on pod</li>
            <li>This proposes Solid as a document-centric ecosystem.</li>
            <li>Straightforward interpretation: LDP presents as a document storage system</li>
            <li>In this interpretation, the documents are the ground truth of the data in the pod.</li>
            <li>Interoperability on top of the document structure is very limiting
              <ul>
                <li>Apps built on the assumption of the interface are very limited</li>
                <li>mismatch in hierarchy, assumptions, permissions (i, ii, iii)</li>
                <li>limiting in the achievable interoperability</li>
                <li>Enrichment of data through semantics is no driver in this interpretation - these are captured in local assumptions of applications.</li>
              </ul>
            </li>
            <li>Interop requires understanding of Solid pod as a KG.
              <ul>
                <li>Solid documents can be distilled into a KG</li>
                <li>This allows us to work on the full information space in the data pod</li>
              </ul>
            </li>
            <li>There are issues though
              <ul>
                <li>documents are the ground truth of the pod, KG is only a derived view</li>
                <li>There is no definition as to what constitutes the KG in an LDP environment:
                  <ul>
                    <li>only the resources?</li>
                    <li>the full interface data + resource data?</li>
                    <li>what about statements made about a resource that is a collection of statements?</li>
                    <li>what about building apps on resource timestamps, …</li>
                    <li>-&gt; no clear conversion!</li>
                    <li>No clear inverse correlation as well, going from a KG to an LDP interface is not always possible, as LDP requires encapsulation of statements in resources, …</li>
                  </ul>
                </li>
                <li>Additionally, the permission structure that is tied to the LDP structure makes sense in LDD interpretation, but loses its meaning in a KG interpretation, as permissions are now tied to arbitrary collections of statements.</li>
                <li>Other requirements for the ecosystem for application interoperability (asking access, …), are tied to the constraints of the LDP interface.</li>
                <li>requirement for documents means inherent reliance on implicit assumptions that are not captured in the data itself, but are tied to specific understanding of what a document is by applications. (e.g. this is data from this app, this should only be managed by this app, …).</li>
                <li>writing data to the pod KG is only possible by wrapping statements in a resource somewhere on the pod</li>
                <li>interpretation of apps as a document centric ecosystem may lead to lack of semantic info in the data, as it is interpreted as document system where these assumptions are encoded in the API, leading other apps to miss out on important aspects of the data.</li>
              </ul>
            </li>
            <li>We see signs of the original vision being construed to this view of Solid as a permissioned KG
              <ul>
                <li>as they proposed an optional SPARQL interface on top of the pod,</li>
                <li>and a QPF from inrupt now currently</li>
                <li>leading to a vision that the interpretation of Solid as a KG would be necessary from the start.</li>
              </ul>
            </li>
            <li>The current LDP + WAC seem to currently form an environment that is designed as an (awkwardly constrained) proxy for a permissioned hybrid KKG</li>
            <li>Where document-centric vision can provide an simple mechanism for data management for a single app, it provides many challenges for a Web ecosystem where interoperability and the separation of app and data are central concepts.</li>
          </ul>
        </li>
      </ul>

      <hr />

      <ul>
        <li><strong>A graph-centric interpretation of the Solid pod</strong>
          <ul>
            <li>We see that the current implementation of Solid as fundamentally document-centric, that can be distilled into a KG leads to issues.</li>
            <li>In this work, we want to propose an interpretation of the Solid pod as fundamentally a permissioned, hybrid, knowledge graph.
              <ul>
                <li>Permissioned: we can store permissions per entity in the knowledge graph -&gt; but more fundamentally we can expand this vision to parameterized KG, where we can store permissions, provenance, and other information for triples in the KG.</li>
                <li>Hybrid: triples and blobs(documents) are first-class citizens in the KG</li>
                <li>KG: definition from paper linked by RUben V on mm.</li>
              </ul>
            </li>
            <li>In this interpretation, the KG is the ground truth of the data in the pod.</li>
            <li>Interfaces interoperate with the KG, and not though a proxy of working with documents</li>
            <li>This vision focuses mainly on management issues (perms, writing, …) with the document-centric interpretation as a KG, but is in terms of querying fuly compatible with the document-based interpretation -&gt; all data you can access in KG -&gt; query</li>
          </ul>
        </li>
      </ul>

      <hr />
      <ul>
        <li><strong>comparison</strong>
          <ul>
            <li>
              <p>We compare the different interpretations of Solid pod in the capabilities of the current ecosystem.</p>
            </li>
            <li>we compare using a contact-list-app, a birthday-list-app and a car sharing app.
              <ul>
                <li>compare on the point of hierarchy:
                  <ul>
                    <li>mismatch in hierarchy leads to limited to no interoperability for 2 apps intepreting it as LDDs, but third app interpreting pod as KG can query all data from all 3 apps.</li>
                  </ul>
                </li>
                <li>compare from point of permission:
                  <ul>
                    <li>2 apps interpreting as LDDs just write contact info as full contacts. Third app writes public and private resource per contact for information. However, when sharing the available contacts, through a mismatch of permission structure, it shares all contact details of the contacts written by other apps -&gt; permission structure DOES NOT MAKE SENSE in the KG interpretation</li>
                  </ul>
                </li>
                <li>compare from point of optimization:
                  <ul>
                    <li>2 apps interpreting as LDDs can set the structuring of the data to optimize data retrieval.</li>
                    <li>3d app may make use of systems such as type index, but other apps dont use it because they know where their data is, so optimization is very limited for app 3.</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>We see that  even in the LDP-based ecosystem, the KG interpretation solves the data interop issues in the examples.</li>
            <li>We show that the interpretation of Solid as a KG actually ignores all the indexing of the Solid LDP API, and only uses it to build its internal KG representation.</li>
            <li>We show that the LDP API is limiting in terms of permissions and optimization.</li>
            <li>In short: the LDP API did not really help us at all and only sets (in the term of the KG representation) arbitrary constraints on the permissions that can be set</li>
          </ul>
        </li>
      </ul>

      <hr />

      <ul>
        <li><strong>Conclusion</strong>
          <ul>
            <li>The current Solid ecosystem is open to interpretation</li>
            <li>In this work, we presented two interpretations</li>
            <li>Currently, we notice a lot of application development and initiatives adopting the document-centric interpretation.</li>
            <li>Where the document centric interpretation of Solid provides a straightforward interface, it leads to limitations in interoperability proposed in the vision.</li>
            <li>To move towards an interoperable ecosystem, we move towards the understanding of a pod as a knowledge graph to solve these interop problems (even the initial Solid paper shared this vision through their optional SPARQL, later removed from spec)</li>
            <li>We argue that even through this understanding, the interpretation of Solid as a document-centric ecosystem limits the innovation surface to the constraints of the document system (perms, assumptions, adaptations to the KG cannot always be translated back into the documents, …).</li>
            <li>We proposed the interpretation of a pod as a fundamentally a knowledge graph.</li>
            <li>We argue that the KG-centric interpretation of Solid provides an innovation space that is much larger than a document-centric interpretation.</li>
            <li>Hybrid knowledge graph manages documents and data</li>
            <li>With this work, we hope to guide future discussion and innovation in the Solid ecosystem to consider the consequences of their interpretation of the ecosystem</li>
            <li>and we propose that where both interpretations can have their merits, the KG interpretation leads to a larger innovation surface for a fully interoperable ecosystem with separation of application and data.</li>
            <li>
              <p>In future work, we plan to look into how these interpretations can be reconciled, or made to work together in a single ecosystem.</p>
            </li>
            <li>We conclude that:
              <ul>
                <li>(i) For interoperability purposes, the understanding of Solid as a KG is key</li>
                <li>(ii) The document-centric interpretation of Solid leads to a limited innovation surface, certainly in terms of management of personal data (perms, writing, … all the issues).</li>
                <li>(iii) For the understanding of Solid as a KG to work from a management perspective where we make multiple applications interoperable on our data, we need to interpret Solid fundamentally as a permissioned, hybrid knowledge graph.</li>
                <li>(iv) Document-centric use cases largely compatible with KG vision in cases where data management does not need to be interoperable.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

    </div>
</section>

  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">The Solid vision</h2>
      <!-- problem: your data being everywhere, no control very limited interoperability -->
      <p>In the current Web ecosystem, the concepts of data ownership and privacy have lost a lot of meaning with user data being captured by corporations in walled data silos.
In this system, the user neither has the control nor the knowledge to manage how their data is being used online. <a href="">TODO:: good citation</a>
<!-- Solid: a vision for a better Web -->
As a response to this, the Solid project <a href="">TODO:: cite</a> was created with the aim of revitalizing the Web.
Where centralized data silos create an ecosystem of limited integration, limited availability and limited innovation,
Tim Berners-Lee’s Solid brings a new vision for the Web.
<!-- ecosystem goal: control over data, interoperability over applications and data -->
An ecosystem that empowers integration and innovation through the separation of data away from services and applications, 
where users are put back in control of their data.
Introducing the concept of the personal online datastore (pod), 
the Solid pod forms the foundation of the ecosystem as a decentralized network of data,
where applications integrate data from the available sources in the decentralized network,
in contrast to the traditional Web where applications integrate data through APIs exposed by centralized data silos <a href="">TODO:: cite reflections of knowledge</a>. 
<!-- key for achieving requirement: capture semantics in the data -->
Where essential information for applications to work with data
is traditionally often encoded in assumptions of the application
or in the semantics of specific interfaces [TODO:: cite? sources?],
the envisioned ecosystem relies on the availability of this information
encoded in the semantics of the available data.
<!-- enables: data integration instead of interface integration -->
Through the transition from semantics encoded in interfaces and application assumptions,
an ecosystem is created based on the separation of data and applications.</p>

      <!-- Now this vision has to be made a reality -->
      <p>From the envisioning of an ecosystem that can form the next step for the Web,
a challenge is posed in how these concepts interoperability and innovation can be 
captured in specific systems for the Web. <a href="">TODO:: wording choice?</a>
<!-- The vision is room for many interpretations -->
As the vision proposed above is broad in terms of concepts,
the understanding of these concepts be equally divided.</p>

      <p class="comment" data-author="RD">Where the vision for interoperability can be understood as the ability for applications to seamlessly integrate data from multiple sources,
others may understand this concept as simply the sharing documents over the Web.</p>

      <!-- there is no authoritative definition -->
      <p>Additionally, there is currently no authoritative definition for Solid, nor the concept of the Solid pod.
Because of this, initiatives in the Solid ecosystem currently work on definitions for the ecosystem
that are a reflection of their interpretation of the vision and their understanding of the current ecosystem.
<!-- leads to misunderstandings that confuse the product of the Solid pod with the envisioned ecosystem. -->
This leads to a rapidly evolving ecosystem, 
where individual assumptions are made that are not shared by the ecosystem,
and where proposed solutions may lack longevity in the context of the evolving ecosystem.
<!-- work proposition -->
In this work, 
we describe two interpretations of the Solid pod in the envisioned ecosystem.
in <a href="#documentcentric">Section 3</a>, we describe the document-centric interpretation that is supported by the current implementation, 
as well as an evolution of the ecosystem towards a more graph-centric perspective.
In <a href="#graphcentric">Section 4</a>, we describe a graph-centric of the Solid Pod as fundamentally a permissioned, hybrid knowledge graph
as a necessary interpretation to expand the innovation surface for the ecosystem.
<a href="#comparison">Section 5</a> provides a comparison on the consequences of the chosen interpretation on the ecosystem,
after which we bring our conclusions in <a href="#conclusion">Section 6</a></p>

    </div>
</section>

  <section id="documentcentric" inlist="" rel="schema:hasPart" resource="#documentcentric">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">A Solid pod as an LDP interface</h2>
      <!-- Solid requires splitting of apps and data through semantics -->
      <p>To achieve the envisioned ecosystem of data integration and interoperability, 
Solid relies on the premise that it is possible to separate applications and data in a meaningful way, 
so that different applications can be interoperable through the semantics stored in the data. 
To achieve this envisioned ecosystem, the Solid project has chosen for the Linked Data Platform (LDP) specification <span class="references">[<a href="#ref-1">1</a>]</span> specification to define the protocol of how applications can interact with data on a Solid pod. 
This specification defines a platform that organizes data using the concepts of resources and containers, similar to how a file system defines a platform that organizes data using files and directories.
It also defines the protocol to create, read, modify and delete these resources and organize them in the hierarchical structure of resources and containers.
Similar to files on a file system, the definition of what constitutes these resources is very loose and generally take the form of either a resource containing a set of statements in RDF (RDF resource) and other resources that do not contain RDF such as images (non-RDF resources).</p>

      <h3 id="a-mismatch-between-ldp-and-the-envisioned-ecosystem">A mismatch between LDP and the envisioned ecosystem</h3>
      <!-- LDP leads to mismatch between the restrictions imposed on how data can be stored, and the real world  -->
      <p>Where LDP has the appearance of a simple interface to make data interoperable over the Web using HTTP(S) protocols, 
it leads to a mismatch with the envisioned ecosystem in the way it restricts the way data can be stored over the interface, 
as well as in the degrees of freedom it leaves open for applications to encode semantic information in the application logic and the interface.</p>

      <!-- mismatch -->
      <p>We can define four points where we see a clear mismatch in the context of two simple applications: a <em>contact list application</em> and a <em>birthday list application</em>, that are built on top of the Solid ecosystem where pods expose their data using LDP:</p>

      <!-- organization -->
      <p>(i) There is no single way to organize data in a hierarchy. 
Data graphs can be modeled in an infinite amount of ways using LDP, by distributing a data graph over different resources and by structuring these resources in different ways over the LDP hierarchy. 
In our example, the contact list application can encode their contacts as separate resources for each contact in its data graph, after which it adds these resources in the LDP hierarchy. 
In this hierarchy, the birthday list application has no option but traversing the entire LDP hierarchy to look for contact data, 
as the data can be stored anywhere and is entirely dictated by the logic in the contact application and the LDP hierarchy.</p>

      <!-- mismatch in hierarchy -->
      <p>(ii) Different applications can disagree in how the same data should be organized in the hierarchy.
Where the contact list application and the birthday list application work on the same data, 
the applications may have different assumptions on how this data should be organized.
The contact list application may assume that contact data should be organized as separate resources, 
where for each contact extra information such as birth dates is stored in an separate extra resource.
In contrast, our birthday list application assumes all contact information should be stored in a single resource.
Because of these assumptions the birthday list application may decide, after navigating the entire LDP hierarchy,
that the contact information it found just does not include birth date information.
In this example, because of the mismatch in assumptions between the applications, data interoperability cannot not achieved.</p>

      <!-- hierarchy for permission -->
      <p>(iii) The permission structure is linked to the data granularity and hierarchy.
The current Solid ecosystem has two specifications that can be used to manage authorization of data on a Solid pod.
There are two specifications that can be used to manage permissions on a Solid pod: the Web Access Controls specification (WAC) <span class="references">[<a href="#ref-2">2</a>]</span> and the Access Control Policy (ACP) <span class="references">[<a href="#ref-3">3</a>]</span> specification.
Both specifications limit the granularity with which permissions can be set on data to individual resources.
In the LDP hierarchy, this means that applications and the pod owner are limited in how they can set permissions over their data
by the structuring chosen by the application writing the data to the Solid pod.
In our example, the contact application may decide to separate all information of each contact as separate resources.
This way, the application and the pod owner can have very fine-grained control over the permissions set over the data.
The birthday list application is not that concerned with this, and decides to just write a single resource for every contact it has.
We see that even more assumptions may break here, as even with access to the contact, the birthday list application may assume it has access to the contact birth date, which may not be the case.
Additionally, the contact information may assume it is sharing only partial information by sharing a contact, while this data was actually written by the birthday list application that just dumps all contact information in a single resource!
In this example, we see how the authorization mechanisms in the Solid ecosystems make problems worse as even more assumptions need to be made in applications.</p>

      <!-- hierarchy for optimization -->
      <p>(iv) Applications may choose to make local assumptions for optimization purposes.
As the contact list application may want to prepare itself in case a users adds thousands of contacts, 
the application may optimize the way it stores is data on a Solid pod to improve queries for data.
The application may create a <em>contacts</em> container, in which creates resources for every letter of the alphabet, 
in which it stores all contact data of contacts whose name property begins with that letter of the alphabet.
In contrast, the birthday list application may create a separate hierarchy for each month of the year, 
over which it stores its resources.
Where both applications try to optimize queries for their application,
their structuring of the data become incompatible and may actively make queries for other applications worse than when just writing all data to a single resource,
because the assumptions that the applications take in their optimization of the structuring of the data that they query do not hold for all applications in the Solid ecosystem.</p>

      <!-- We see this as a consequence of LDP certain restrictions, but also leaving a lot of degrees of freedom, leaving developers free to use a Solid pod as a remote file system -->
      <p>The common source of these problems can be found in applications using the the LDP interface of a Solid pod to encode their own interface through the structuring of their data on the Solid pod.
In these instances, applications are not really using LDP as an interface, but as a tool to define their own views on their data on the Solid pod.
By encoding these local assumptions and optimizations in the application logic and the LDP interface, 
the resulting data often lacks the required semantic information to be interoperable for applications in the ecosystem.
In this way, the LDP interface of a Solid Pod limits the innovation surface of the ecosystem, as in many cases it fails to get the assumptions encoded in the application logic and the LDP interface as semantic information in the data stored on the Solid pod.</p>

      <p>We find that the optimizations done by applications to solve problems in the LDP hierarchy they work with, 
lead to solutions that are either localized in the application logic and LDP interface, 
or lead to solutions based on encoding more semantic information in the LDP interface, 
such as agreeing to store contact information in the <em>/contacts/</em>  container, 
that miss the long term goals for the Solid ecosystem.</p>

      <!-- 
----------------------------
OLD STUFF
----------------------------
 -->

      <!-- applications are required to make localized assumptions and optimizations to read and write data on a Solid pod over LDP -->
      <!-- The LDP interface restricts the way applications can store data by requiring the bundling of data into resources and the organization of these resources in a hierarchical structure. The responsibility of this organization of data lies entirely with the applications.
This situation leads us to the following problems we witness in the current Solid ecosystem:
(i) as the authorization mechanisms for Solid limit the expressiveness of permissions to the granularity of resources and containers, applications indirectly dictate the structure over which the user can control access to this data.
(ii) the imposed hierarchical structure may not conform to real-world requirements for the structuring of data. This may encourage local assumptions in the application to model this data, where these assumptions should be captured in the semantics of the data itself. 
(iii) as the LDP interface leaves a lot of freedom in how data can be written to the pod, and because of the similarities between the LDP interface and a file system, developers are allowed to encode local assumptions and optimizations of the storing of data in the organizational structure of data as can be done on file systems. Where these assumptions do not hold for the rest of the ecosystem, this leads to problems with interoperability or loss of optimizations by this information not being stored in the semantics of the data.

 -->

      <!-- 
### A lack of definition
As the Solid project evolved over time, we start to notice that the lack of an authoritative definition for Solid (that we know of) has had the consequence that the understanding of what Solid has started to shift.
From being initially described as "*a decentralized platform for social Web applications*" <span class="references">\[<a href="#ref-4">4</a>\]</span>, over time initiatives within the Solid ecosystem started providing their own definitions as to what Solid is based on their vision of the ecosystem.
On the Solid project (https://solidproject.org/) website, we find that "*Solid is a specification that lets people store their data securely in decentralized data stores called Pods.*".
The Inrupt website (https://inrupt.com/solid/) states that "*Solid is a technology for organizing data, applications, and identities on the web.*".
As these definitions start to diverge in terms of terminology and viewpoint, we fear that the definition of the Solid ecosystem may become more tied to the specifications used to implement its goals and miss the original promise of an interoperable ecosystem for applications and data.


How do I do a full citation style for the part of: the initial description in (sambra et al.)[] . And additionally how do we give the references through footnotes? I heard this cant be done - do i do it inline?
{:.comment data-author="RD"} -->

      <!-- 
Additionally, we notice that the inconsistency in used terminology to the identity of Solid as a platform, technology, specification or protocol. Next to this, from our experience with the tooling and initiatives,
In contrast, the current specifications (WAC, ACP), research [TODO:: find something good here??]() and tooling is all focused on viewing Solid as a Linked Data Platform interface.
[TODO:: we need more content here to prove this point]().

Because of this notion of a Solid POD being equated to the Linked Data Platform interface is exposes, in contrast to viewing this interface as a means to an end to achieve the original goal of splitting applications and data while providing semantics in the data itself, we argue that this current perspective enforces the problems that currently exist with using the Linked Data Platform specification as a base for the Solid ecosystem and limits the potential for innovation and solutions that the Solid ecosystem can bring to the Web.

 -->

      <!-- Missing the point: We argue that LDP with WAC / ACP has the goal of creating a developer-friendly approach of presenting developers with a file-system like interface to use data over the Web, with a we'll fix it later attitude. But this leads to developers using this interface just like a file system and missing the point of adding semantics to their data to help the interoperability. -->

      <!-- 
It puts constraints on the data - resource granularity, hierarchical structuring, but also leaves degrees of freedom used to create additional semantics not captured in the data.
This freedom is used to create API's in the data through local assumptions creating semantics that may not be captured 
However, if we look at the implementation these definitions differ We notice a lack of proper definition for Solid, nor a guideline for used terminology (protocol, platform, ecosystem, ...).in the data itself.
Little support for interoperability in its base form.

#### Resources are organized in a hierarchical structure using containers.
This hierarchical structure 


#### Resources do not impose any structure on data



In this bundling of data in resources and organizing these resources in a hierarchical structure, we see a mismatch with how 

In this bundling of data in resources

In this hierarchical structuring of data, we see a mismatch with the structuring of real-world data.
As applications 
As data must be collected in resources and placed in a hiera
 -->

      <!-- 


-----------------

### Solid as a Linked Data Platform interface

LDP as a meta-API where applications are able to model their data needs.
It puts constraints on the data - resource granularity, hierarchical structuring, but also leaves degrees of freedom used to create additional semantics not captured in the data.
This freedom is used to create API's in the data through local assumptions creating semantics that may not be captured 
However, if we look at the implementation these definitions differ We notice a lack of proper definition for Solid, nor a guideline for used terminology (protocol, platform, ecosystem, ...).in the data itself.
Little support for interoperability in its base form.

#### A mismatch between data organization and the real world
is often caused by the Linked Data Platform interface being restrictive in the way data can be organized over the interface.
The Linked Data Platform specification organizes data in a hierarchical structure, where real-world data does not always follow a hierarchical structure.



#### Semantics in data organization
in applications and 


#### Localized assumptions and optimizations
made by applications in the structure of data stored on a data pod leads to ...

#### Applications indirectly dictate the permission structure
in their structuring of data on the data pod.
As applications structure data stored on the data pod, 
the resulting data organization on the pod dictates how permissions can be set over this data.
As the data is structured in resources using the hierarchical structuring of the Linked Data Platform interface,
permission granularity over this data is limited to the size of the chosen resources, and not on individual data triples in these resources (in case of RDF resources).
Additionally, interactions with this data is limited to the structuring of these resources, as [TODO:: what more should we put here??]().
 -->

      <!-- 


--------------------------------------------

#### Data granularity
A consequence of using this specification is that data must be organized in resources, as this is the only form of data that can be managed using Linked Data Platform. This requires applications to make local assumptions as to what constitutes a resource and how application data should be distributed over resources in a data pod. As resources are the only interface, other data structures such as databases are impossible, and must be emulated on the client side over the resources exposed by the LDP interface.

#### Organizational semantics
As resources are stored in a hierarchical way due to the nature of the Linked Data Platform specification, the organization of data in a hierarchical order may carry implicit semantics in the organization of resources on a data pod. We see this return in the original paper<span class="references">\[<a href="#ref-4">4</a>\]</span>, where the example is given of an application storing events using a URI path structure based on dates (i.e., /2016/05/01/event1). The problem with these localized assumptions is they do not hold for the ecosystem, and form an application specific API built on Linked Data Platform [TODO:: what more?]().

#### Hierarchical bias
The hierarchical organization of data on a pod also leads to data separation between applications. We see this with e.g. Digita [TODO::source]() providing a separate container for each app, in the same way that the `Program Files` folder provides a location for applications to store data. While this mitigates issues of overwriting data, and adds implicit context to data based on its location (at least for the application managing a certain data space), this comes at the cost of data discovery and integration [TODO:: what more?]().

#### LDP as a meta-API
We argue that the Linked Data Platform interface is not an API, but a meta-API that can organize data in an infinite amount of ways. In the current environment, applications are forced to make local assumptions, and create application-specific API's on the Solid data pods through localized assumptions that do not hold for the ecosystem. This comes at the cost of data discovery and interoperability with different applications that do not share the same assumptions.

### API-integration versus data-integration

As the goal for interoperability of online data spaces is to move from the paradigm of API integration to mode data integration centered approaches of data publishing, we see that Linked Data Platform in it's current state creates API integration issues for applications through localized assumptions in data organization and format / shape [TODO:: maybe also make the point of format / shape integration a bit more]().



The original paper proposes a solution for data discovery through providing a SPARQL interface that runs on top of the data organized in the Linked Data Platform, where every resource serves as its own SPARQL endpoint (https://github.com/nodeSolidServer/node-solid-server/issues/962) which has since been removed from the spec -> this was no solution after all so maybe this should be casually mentioned as a sidenote?
 -->

      <!-- 

As a consequence of these decisions, using the Linked Data Platform interface, reading this contact data requires the knowledge of where the data is stored, and the formatting in which the data is stored to work with the data.

As a consequence of using LDP for the organization of resources on a data pod, the main discovery mechanism over this interface is link traversal through the LDP interface.
This is however a limited approach, as in case an agent tries to retrieve information stored in a public resource at at `&lt;pod_uri&gt;/private/public`, where the parent container `&lt;pod_uri&gt;/private/` is set to be private, the resource cannot be discovered unless the exact URI can be discovered through another means.

In their "extensions to LDP" part of the paper, they propose the "PUT" extension to LDP, with the example of a calendar application
that uses a URI path structure based on dates (i.e., /2016/05/01/event1). A PUT request is to create a new resource called event1,
as well as the missing month (i.e., 05) and day (i.e., 01) containers under /2016.
Here we see again the reliance on the LDP bias (using the slash semantics as semantic information over the stored data instead of explicitly tagging the data with the information), that leads to assumptions being required to discover the data.

The complex data retrieval proposed through SPARQL mentions that optionally a SPARQL endpoint can be provided on a data pod, enabling more complex data queries from a pod, where rdf-resources and metadata for non-rdf resources can be exposed over the interface.
This is to address shortcomings in the LDP interface of not being able to express complex data retrieval operations such as filtering and aggregation. Also proposed here is that pod servers may be responsible for evaluating queries spanning multiple pods by forwarding requests for additional data to other pod servers.

In their related work, it states:
Solid has a strong focus on decoupling data from
applications and in addition ensuring that applications have a simple, generic
and well defined way to access the data stored in the users’ pods.




In Section 5, the paper presents the POD Management system. It defines that pods use LDP to organize data in containers that group resources with every resource and container having their own URI. A pod server should support 
- LDP
- patching (N3-patch, former SPARQL update)
- access control lists (ACL), potentially to be updated to access control policy(ACP).
- live updates
- optionally SPARQL

They advise storage mechanisms for RDF data to use triple stores to facilitate querying.

From all this information, we infer that their approach is focused on data discovery and querying happening mainly over a SPARQL interface that has a full index of all data that is available to the agent querying over the pod and can fulfill these requirements on the server side.



### LDP as an API
Additionally, we also argue that LDP is not an API: it’s a meta-API. 
There are still an infinite amount of ways to expose knowledge over LDP. 
We notice existing work and apps get this wrong[TODO::cite]().


Because of this, we see that the promise of Solid moving the equation from API-integration to data-integration does not hold.
As LDP cannot be viewed as a simple API, the problem of integrating different API's to access data from different sources 
has been translated into requiring knowledge of different writing / storage methods to access data stored on different pods by different applications,
leading to a different kind of API integration, without providing the data-integration that was promised. -->

      <!-- 


------------------------------------------------------------------




A disconnect exists between the practical notion of a Pod and the protocol that provides access to its data, creating confusion as to what exactly a Pod is and how it relates to the technical specifications.

- LDP creates biases in the stored data?
- data integration issues w LDP?


- spec updates evolved the understanding of Solid pods
- the technical specifications put limits on the way data can be interacted with
- to attain the goal of replacing the API integration with data integration, have to work around the limitations of LDP or build alternative interfaces on top.




The current state of LDP makes us think of pods as collections of Linked Data Documents

We see a fundamental mismatch with usage.
We see different apps making local assumptions and optimizations that do not hold for the ecosystem and essentially because of ACL reasons

LDP creates a BIAS in the stored data? e.g. data has to be grouped at a certain location in a resource?
Also the notion that LDP is not an API. It’s a meta-API; there are still infinity ways to expose knowledge through LDP. So existing work and apps get this wrong.

-> The promise of data integration instead of API integration is not satisfied? - This was a point we came up with, however this can be (kinda) solved in the tooling used so ?
-> ...

The Mansouroriginal Solid paper already alluded to shortcomings of the LDP interface (globbing, a separate SPARQL interface for RDF data / metadata)
-> And we will make the argument / take the position that it is more fundamental, that LDP is the problem/limitation rather than the solution. We reframe by seeing one LDP API (there are multiple!) as a possible view on the Pod, which fundamentally is a KG. 

-->

    </div>
</section>

  <section id="graphcentric" inlist="" rel="schema:hasPart" resource="#graphcentric">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Interpreting the Solid pod as a permissioned Knowledge Graph</h2>

      <h3 id="explain-what-we-do---what-is-this-concept">Explain what we do - what is this concept?</h3>

      <p><em>Herein we adopt an inclusive definition, where we view a knowledge graph as a graph of data intended to accumulate and convey knowledge of the real world, whose nodes represent entities of interest and whose edges represent relations between these entities. The graph of data (aka data graph) conforms to a graph-based data model, which may be a directed edge-labelled graph, a property graph, etc.</em></p>

      <!-- Explain the consequences -->
      <p>### A better match for the ecosystem</p>

      <p>Looking back at the mismatches we noticed examining the Solid ecosystem of Solid pods as an LDP hierarchy (Solid as LDP),
we now can examine what happens when we look at these problems from the interpretation of Solid pods as fundamentally being a permissioned Knowledge Graph (Solid as KG):</p>

      <!-- the world is not a hierarchy -->
      <p>(i) There is no single way to organize data in a hierarchy. 
Where Solid as LDP imposes its LDP hierarchy on the way data is modeled over the interface,
the interpretation of Solid as KG does not impose these constraints.
The Solid as KG interpretation implicates that we can create any hierarchy over the data in the Solid pod.
As the organization of data is not restricted to the API, any application can decide their view of the world 
and encode the accompanying assumptions in the way they query this knowledge graph over the interfaces they use to interact with the Solid pod knowledge graph.</p>

      <!-- different hierarchies for same data -->
      <p>(ii) Different applications can disagree in how the same data should be organized in the hierarchy.
This follows from the previous point, as the Solid as KG interpretation does not impose any hierarchy over the data in the Solid pod.
Any application is free to structure the available data in a hierarchy of choice 
and there is no need for applications to agree on any hierarchy for the same data.</p>

      <!-- hierarchy and permissioning / granularity -->
      <p>(iii) The permission structure is linked to the data granularity and hierarchy.
Permissions and policies should follow from this. - caveat - resources can still exist on level of API but not on the level of KG.
<a href="">TODO:: make this point a bit better?</a></p>

      <!-- optimizations through hierarchy -->
      <p>(iv) Applications may choose to make local assumptions for optimization purposes.
We can see that where Solid over LDP entices
optimization through data semantics and APIs instread of orgnization of data over an interface.</p>

      <ol>
        <li>
          <p>world is not hierarchy
- no problem, we have the graph we can get any hierarchy that we want.
We can create a virtual API that maps /events/ to a SPARQL query -&gt; any application can choose how to view the world / data, organization of data is not restricted to the API. No need to agree.</p>
        </li>
        <li>
          <p>different hierarchies of same trueths -&gt; flows from the first point.</p>
        </li>
        <li>
          <p>issue wth permissioning -&gt; flows from first point. Permisisons and policies should follow from this. - caveat - resources can still exist on level of API but not on the level of KG.</p>
        </li>
        <li>
          <p>optimizations - optimization through data semantics and APIs instread of orgnization of data over an interface.</p>
        </li>
      </ol>

      <!-- Repeating the premise -->
      <p>The concept of the separation between application and data made possible by the capture of semantics in the data itself forms the premise for the proposed Solid ecosystem.
<!-- The current problem in 2 sentences -->
The current implementation and lack of authoritative definition for Solid is shifting the understanding of the Solid ecosystem and may cause limitations in the development of long term solutions to the problems faced with with the realization of the ecosystem.
<!-- The proposed perspective !!!! -->
To frame the understanding of Solid in a place that is closed to its core premise, we take the perspective that a Solid Pod is fundamentally a permissioned hybrid knowledge graph, exposed through Web APIs. 
In this perspective, we can view a network of multiple Solid Pods as decentralized, permissioned, hybrid knowledge graph.</p>

      <p class="comment" data-author="RD">Make sure we agree on this perspective</p>

      <!-- 
Jesse proposal:

Solid as a platform serving data Pods that provide sufficient views on the data **available to the entity interacting with the pod** that it can be organized as a permissioned knowledge graph.
-->

      <!-- What is a permissioned knowledge graph -->
      <p>With the term <em>permissioned</em> knowledge graph, we express the that the Solid pod knowledge graph enables managing the available permissions of the stored data.
The definition of a knowledge graph that is exposed through Web APIs opens up the notion of supporting any Web API that can expose knowledge graphs over the Web, 
and makes clear that any interface used to interact with a Solid pod should be a means to an end and not define and limit the innovation surface of the ecosystem.</p>

      <p>Note that where we use the term <em>permissioned</em> knowledge graph, we make this choice as this leans close to the original proposition for Solid. 
We recognize that in the same way permissions are can be seen as specific implementations of policies, 
the concept of a permissioned knowledge graph serves as a base for more dynamic means of managing access to the Solid pod knowledge graph such as policies.
<!-- Make the point that Solid as LDP emulates a permissioned knowledge graph, but leads to getting stuck on certain points -> problem statement -->
In the frame of the proposed perspective, we view the current state of the Solid ecosystem as a specific implementation of the perspective, where the Linked Data platform takes the form of one of the available interfaces to interact with the Solid Pod.</p>

      <!-- Make the point that interfaces can be thought of as independent building blocks for management of data, permissions, ... -->
      <p>In the context of this perspective, 
we can define the specifications that act as the interfaces to interact with a Solid pod as building blocks for the Solid ecosystem.
This is in line with the current trend of authorization specifications such as Web Access Controls (WAC) <span class="references">[<a href="#ref-2">2</a>]</span> and Access Control Policy (ACP) <span class="references">[<a href="#ref-3">3</a>]</span> being exchangeable building blocks for the ecosystem.
Similarly, the existing LDP implementation is can be seen as an available building block for the interface to manage data on a Solid pod.
These building blocks in the Solid ecosystem should be developed to be minimally interdependent to facilitate their reuse in different contexts.</p>

      <p class="comment" data-author="RD">Does WAC and ACP have to be cited? or do I just leave that out / footnote it would be ideal but that doesnt work here?</p>

      <!-- 


### Permissioned Knowledge Graphs
With the goal in mind of separating the data and applications, we propose the perspective of Solid as a permissioned knowledge graph.

Note that where permissioned knowledge graph, we understand a knowledge graph that can assign permissions for any data quads contained in the knowledge graph. We see the permissions set here as a proxy for policy-based authorization for data, where policies can dynamically describe permissions over data [TODO:: redo this]().


in our perspective is a Knowledge Graph where any collection of data can be grouped under a specific set of user permissions or policies.


### API integration
A consequence of an ecosystem where knowledge graphs can be exposed over the Web over multiple interfaces, is that this brings us back to the problem of interface-integration.

For this perspective to work, we must strive to transition from an ecosystem of API integration towards an ecosystem of data integration.

We argue that the use of Linked Data Platform as an organizational structure for data on a Solid pod relies too much on applications creating localized assumptions and optimizations for the structuring of their data that do not hold for the ecosystem, leading to applications requiring to do API integration on top of these structures, where semantics of the data may encoded and lost in this structuring instead of the data itself.

Where assumptions are currently contained in the API used to organize the data on a data pod, we need to move these assumptions to the data and explicitly encode them into the semantics of the data.

In the perspective as a pod being a permissioned Knowledge Graph that can be exposed over a multitude of APIs, we argue that exposing data over well-defined APIs can alleviate API integration problems.
[TODO:: HOWW???]()



### Interface building blocks

In this context, we can view the current state of Solid as pods that expose their internal knowledge graph over building blocks for authorization (WAC / ACP), data management and querying (LDP) and authentication (Solid-OIDC).
In this context, interface building blocks in the ecosystem should try to be minimally interdependent, to promote reuse over multiple interfaces for other components of Solid.

As a practical example, where the original paper advertised SPARQL as a possible interface to optimize querying on top of the Linked Data Platform data management layer <span class="references">\[<a href="#ref-4">4</a>\]</span>, we propose that a SPARQL endpoint may serve as a querying and data management interface on top of the knowledge graph, requiring new building blocks to be researched for authorization over such an interface.




-------------------

With this work, we propose the view of Solid as being data and application independent. 

With this work, we argue that it is not per se the interface of Linked Data Platform that is the cause of issues, but the notion that a Solid pod must adhere to the notion of being an online data space that organizes data as resources over a Linked Data Platform interface.
We pose that the assumptions described above that stem from the use of this organizational structure and the limitations it poses on the data it stores.

We propose the vision of Solid as a platform serving data pods that organize data as a Knowledge Graph <span class="references">\[<a href="#ref-5">5</a>\]</span> <span class="references">\[<a href="#ref-6">6</a>\]</span>.

A network of Solid pods can be seen as a decentralized knowledge graph. 

If a pod can be seen as a Knowledge graph, exposing the contained knowledge can take many forms, as knowledge graphs traditionally have supported multiple interfaces to add, manage and query data [TODO::sources](). 

Say something about integrating interfaces for authorization, data management and querying as building blocks in the ecosystem.

In this vision, a pod can be considered a permissioned, hybrid Knowledge graph that can be accessed through various Web APIs.

 -->

      <!-- 
The Solid paper already alluded to shortcomings of the LDP interface (globbing, a separate SPARQL interface for RDF data / metadata)
-> And we will make the argument / take the position that it is more fundamental, that LDP is the problem/limitation rather than the solution. We reframe by seeing one LDP API (there are multiple!) as a possible view on the Pod, which fundamentally is a KG

-->

      <!-- 

In the original paper for Solid, there was alluded on exposing all data over a SPARQL endpoint

Wat is solid?
- is het een set van protocols?
- is het een concept geimplementeerd met een set protocols?


Solutions can be found through:

extensions to the LDP interface:
- in spec 
- out of spec client managed?
- out of spec client sided?




### Authorization

- Resources are a straightforward way of combining data triples for authorization purposes.
- autorization systems can be adapted to work on a triple basis OR
- other ways of combining triples in resources can be used that do not include LDP biases (slash semantics)
 -->

    </div>
</section>

  <section id="comparison" inlist="" rel="schema:hasPart" resource="#comparison">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Comparison</h2>
      <p>In this section, we examine how the the proposed perspective influences the technological requirements for the Solid ecosystem, from the viewpoints of storage, publication and query.</p>

      <p class="comment" data-author="RD">Are these three viewpoints still the most relevant?
Not really agreeing with this statement anymore -&gt; maybe also adapt abstract</p>

      <p class="comment" data-author="RD">This part has to be achievable in 2 pages. I need some help with this</p>

      <p>To compare the perspectives of a Solid pod in the current ecosystem as a Linked Data Platform interface with the perspective of a Solid pod as a permissioned hybrid knowledge graph that can support any number and type of Web APIs, we set up the following comparison.
We compare an application, storing event data on a user Solid pod.
For the comparison, we look at the current state of the Solid ecosystem where the LDP interface is used to organize the data, and compare this with a scenario where an application discoveres a Solid pod exposes a SPARQL endpoint interface that can be dynamically discovered.
For the comparison, we assume that an event consists of a timestamp, a type, and a message.</p>

      <h3 id="the-linked-data-platform-interface">The Linked Data Platform interface</h3>
      <!-- divide the data in resources -->
      <p>In the current Solid ecosystem, an application working with a Solid pod knows the Solid pod exposes a Linked Data Platform interface to manage data.
To write its data to the pod, the application first needs to decode how to structure its internal data as resources.
To structure the events contained in its internal knowledge graph, the application can take the approach of dividing the events as a separate resource for each event. 
In this case, each event can have its own permissions, as setting permissions in the current ecosystem is limited to resources and containers.
Alternatively, the application might want to bundle multiple events as single larger resources to speed up retrieval. This however comes at the price of not being able to set individual permissions for individual events!</p>

      <!-- finding place to write the data -->
      <p>With the data distributed into several resources, the application now wants to store them on a Solid pod.
If the application does not have access to a location on the pod, it can start up a negotiation protocol to receive access to write data to the pod that is not in scope of this work.
With access given to the pod, the application now needs to organize the created resources of data into a structure that can be written over the LDP interface of data pod.</p>

      <!-- organize the resources on the pod -->
      <p>A first option would be for the application to just write all resources to a single container the application has access to, together with all other application data. Publishing all data as resources in a single container means the application is not making any assumptions as to the organization of data. However, in this case, the LDP interface does nothing to aid the application in finding previously stored data. The application either has to keep an internal state of where resources were stored, or check the available resources on the pod until a match is found.</p>

      <!-- need for structuring -->
      <p>Because of this, it is more interesting for applications to create structure in their data, as through these structures, applications can more easily retrieve written data. To create this structure, the application can create an <code>events</code> folder in their allocated data space, and store all event resources in this <code>&lt;storage_space&gt;/events/</code> location. Now any time the applications wants to read or write events, it can make the local assumption that all event related data <em>written by the application</em> will be stored at this <code>events</code> folder.</p>

      <!-- need for optimizations -->
      <p>But as the application expects to be working with large amounts of event data, it might decide that further optimizations are required. For this purpose, it might want to choose to organize the data according to one of its properties such as the timestamp of the event, or the type of the event. In this case, an event might be stored as the following resource on the pod: <code>&lt;storage_space&gt;/events/2022/01/01/event1.ttl</code>.</p>

      <!-- conclusion -->
      <p>We see that the events stored by the application are now structured according to the assumptions and optimizations done by the application.</p>

      <p>From a <strong>storage</strong> standpoint, the event data is stored on the file system of the POD server as a file, or may be stored in a graph database where the data is tagged as part of that resource, so that the resource can be reconstructed in its entirety.</p>

      <p>From a <strong>publication</strong> standpoint, all data of an event is published as a resource over the POD LDP interface on a location that is tied to the application-specific organization of data.</p>

      <p>From a <strong>query</strong> standpoint, the data must first be discovered on the pod, after which it can be queried directly through dereferencing the relevant resources or by an abstraction on the client that provides access to the data over another interface.
Data discovery can happen using brute-force retrieval of all available resources, but is limited by the permissions an agent has over what can be viewed on the data pod. Additionally, public resources in private containers may lead to brute-force methods not discovering these resources and not including the contained data in their results.
Options external to the LDP interface such as the Type Indexing system <a href="">TODO:: refer</a> and Shape Trees <a href="">TODO:: refer</a> can optimize this process, but as of yet are not mandatory in the specifications and are not required to be managed by the server <a href="">TODO:: is this true for shape trees??</a>.</p>

      <h4 id="model-based-interfaces-sparql">model-based interfaces (SPARQL)</h4>
      <p>In the case of model-based interfaces, we take the well known example of the SPARQL endpoint <a href="">TODO::cite</a>.
A Solid pod exposing its internal knowledge graph over a SPARQL endpoint interface does not impose any requirements on structuring of the data <a href="">TODO:: this is correct right??</a>.</p>

      <!-- No need for data division and organization -->
      <p>An agent interacting with the data stored on a Solid pod over a SPARQL endpoint interface, 
the application is not required to change the organizational structure of the data. 
In this case, the application can directly write its internal knowledge graph of events to the Solid pod without requiring additional data organization.</p>

      <!-- No requirement for optimizations -->
      <p>As the application storing its data on a Solid Pod cannot really organize the data being written in specific ways over the SPARQL endpoint interface, it can only change the data graph that the application is working with.
To be able to find all events, and order them on a timestamp, the application now must make sure that this type and timestamp data is contained in the data itself. Now, on querying the Solid pod knowledge graph, it can use these semantics of the data stored to retrieve all subjects of the type Event, and order them according to their timestamp values.
Any optimizations or local assumptions that the application wants to make over its data, must be encoded in the semantics of the data in the Solid pod knowledge graph itself.</p>

      <!-- Need for additional interfaces for dereferencing -->
      <p>A downside of exposing data over interfaces using an endpoint is that the ability to dereference data on a Solid pod might become impossible. 
As we create event entites in the Solid pod knowledge graph, we want these events to be dereferencable by applications on the Web to discover more information, or discover any interfaces exposing this data.
The original introduction of Solid <span class="references">[<a href="#ref-4">4</a>]</span> proposed that Solid servers may offer optional support for SPARQL as a query interface for the Pod, where the SPARQL interface works on top of the underlying organization of data in resources and containers and the LDP interface provides the functionality for organizing and managing the data and their URIs.
But we can think of other solutions to managing data on a Solid pod.
When viewing a Solid pod as a permissioned knowledge graph, we can for example use subject pages <a href="">TODO::cite</a> as a solution where dereferencing a URI in the knowledge graph leads to a dynamically generated resource containing all data that is linked to the requested subject.
In the case of our example, when dereferencing the URI of an event, the Solid pod may provide an interface that automatically generates all relevant triples for this event.
Note that depending on the interfaces used, the property of symmetric reading and writing, where data being written to a location can be read from the same location and the other way around may not hold.</p>

      <!-- Use of hypermedia links -->
      <p>The interface available to interact with data stored on a Solid pod should be discoverable through hypermedia links in the form of link headers.</p>

      <!-- conclusion -->
      <p>We conclude that use of a SPARQL endpoint interface to organize data on a Solid pod may lead to developers writing assumptions and optimizations for their application to work with the data as semantic information in the data itself, leading to an environment where data has a higher degree of interoperability between applications <a href="">TODO:: can I state this?</a>. On the other hand, we see that in the case of a SPARQL endpoint, additional challenges are created including requiring additional functionality to allow dereferencing of stored data, as well as the loss of symmetric read and write.</p>

      <p>From a <strong>storage</strong> standpoint,</p>

      <p>From a <strong>publication</strong> standpoint,</p>

      <p>From a <strong>query</strong> standpoint,</p>

      <p>Note that not all technology used in this comparison is yet available</p>

      <p class="comment" data-author="RD">TODO:: finish this part fully. Waiting for feedback</p>

      <!-- 
### Storing events on a Pod
A first concrete example we can give is the example of storing events on a Solid pod.
Events are a wide-spread 

We will make this comparison based on the aspects of storage of the data on the pod server, the publication of the data over the Web, and querying of data over the interface.

#### Storage



#### Publication



#### Query

**queries and APIs are separate concepts**


### Comparing interfaces
A common misconception is that a server interface should be identical to the client interface [TODO::cite and word according to Ruben blog](). 
Interfaces however can be abstracted away in a proxy (A web page abstracting an SQL interface in filters), or on the client (Comunica abstracting away a TPF server as SPARQL)[TODO::cite]().

For decentralized networks of data sources such as the Solid ecosystem, these abstractions will mainly be the building blocks for applications to work with data stored on the pods.

We pose that the interface exposing the server Knowledge Graph influences the possibilities and biases for abstractions created over them.
As the Linked Data Platform allows data to be retrieved by retrieving the resources present in the containers and resources advertised by the main index [TODO:: wording??](), consequences of the interface such as public resources in private containers not being discoverable through link traversal of the LDP index will limit the abstractions that can be created over the interface.

Where initiatives such as the Solid Interoperability Specification [TODO::cite]() work to provide answers for these use-cases, they are bound to the organization of data on a pod imposed by the Linked Data Platform specification.


### Data storage comparison
Different interfaces exposing data of a knowledge graph may require different storage solutions to access the underlying data.
Note that again here building blocks providing conversions for different interfaces on specific storage mechanisms may be implemented.

#### Linked data platform interfaces
can use multiple approaches for data storage. The original Solid introduction paper [TODO::cite]() proposed a file-based backend for the storage of non-rdf resources, where rdf resources were stored in a file-based or graph-based system dependent on the optional support for SPARQL over the resources in the pod.

#### [meta-]model-based interfaces
may require more elaborate back-end support depending on the interface exposed. As interfaces such as SPARQL and TPF interfaces rely mostly on an indexed data graph storage mechanisms[TODO:: ...](), 
Support for non-rdf resources must always be taken into account, requiring some sort of organizational structure for these resources to be setup.




### Data publication comparison
The data management interface used by a Solid pod influences how the internal data is published over the Web.
The interface directs how data can be accessed, the granularity of 


#### Linked data platform interfaces
provide a resource-based data organization organized according to the Linked Data Platform specification.

- slash semantics - bias
- data discovery difficulties (type index, interop spec, ...)


#### [meta-]model-based interfaces

- quad / view?-based
- discovery through interface index (SPARQL, TPF, ...)
- non-RDF resource metadata indexing (as in original paper)
- ...



### Data querying comparison
The organizational structure of data published over the interface influences the query resolution and optimization process.
Other differences such as the granularity with which the data can be accessed influences the querying process.

#### Linked data platform interfaces
rely for querying on their data organization, or on derived interfaces to support querying requirements.
As data discovery is hindered by local assumptions made by applications in the organization of data and their shape, either knowledge about the organization of data, or brute forcing of the available resources is required to discover and retrieve data relevant to a query.
The inclusion of optional SPARQL support in the first iterations of the Solid specification [TODO::cite]() supports this.

#### [meta-]model-based interfaces
require the client to discover the exposed interface, and adopt the querying strategy accordingly. A practical example of this is the comunica querying framework, that can adapt its querying strategy according to the datasource interface <span class="references">\[<a href="#ref-7">7</a>\]</span>.
Querying performance and evaluation is dependent on the exposed interface.
Assumptions on the shape of data contained in the internal knowledge graph still provide the same challenges, but the organizational structure of data should be abstracted away for clients working with and querying the data.


### How does the framing of pods as a Knowledge Graph solve the API integration problem?

In the problem statement, we pose that Linked Data Platform is a meta-API that leads to API integration problems.
How does this solve this issue?

We first pose that API's are a means of syncing data between systems [TODO:: cite](), and data retrieval will always happen over an API (even direct retrieval implicates an API, as you know the location of the resource, etc ...) [TODO:: ...]().

The problem with enforcing Linked Data Platform as the single meta-API for Solid is that biases and  -->

      <!-- 
the APIs are just a means of syncing data between systems 
(see https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/#abstracting-away-p-4) 
-> Granted but this does not really provide the comforting words that "we will change the API-integration hell into a data-integration opportunity".

cons -> need to support multiple interfaces
pros -> used interface should not have influence on the exposed data, just on how it can be accessed, as the context remains the same? -> something like this but requires some extra thinking? -->
    </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Conclusion</h2>
      <p><span class="todo">Emphasize that the existing Solid Protocol (LDP+WAC) remains untouched! That both the existing and proposed interpretation are implemented with the same spec. What changes is below the boundary of the spec, namely the role the spec (LDP) plays on the server.</span></p>

      <!-- With this work, we propose perspective of Solid as ...  -->
      <p>With this work, we proposed the perspective that a Solid Pod is fundamentally a permissioned hybrid knowledge graph, exposed through Web APIs. 
<!-- Argue this perspective in itself does not solve the existing difficulties in interoperability  -->
To create the envisioned ecosystem, where through semantic enrichment the separation of applications and data can be accomplished, 
we argue that this perspective is necessary to develop meaningful solutions that promote longevity in their approach.
<!-- Make case that LDP limits the innovation surface for Solid -->
We argue that the current attitude of the Linked Data Platform specification being central to the notion of what constitutes a Solid pod 
promotes a development process of applications making local assumptions and optimizations in their data organization, 
leading to difficulties in creation of the envisioned ecosystem.
<!-- Where LDP can promote assumptions over the API -> we need to get these assumptions in the data as semantics  -->
Additionally, we argue that the current lack of an authoritative definition for what a Solid pod is leads to 
a shift in understanding of the original vision of an ecosystem of application and data interoperability to an
ecosystem defined as the sum of its specifications, limiting the potential innovation surface of the ecosystem 
to the specific choice of specifications.
<!-- The perspective continues from the current state of solid and is completely compatible with the current state -->
We note that perspective proposed in this work does not go against the current state and use of Solid,
but must be seen as an attempt to zoom out the current perspective on Solid,
and provide a framing of the ecosystem that promotes solutions aimed at the interoperability and longevity of the ecosystem.
<!-- The goal of this work is to provide a perspective on the identity of Solid that can help in future work on the topic -->
We do not propose any specific takeaway as to which interfaces may provide solutions for faced difficulties, 
but we hope that the ideas proposed can form the base of new discussions and solutions to tackle the difficulties faced by the ecosystem.</p>

      <!-- -------------------

The insights proposed in this work are crucial to eliminate 
the dependency of Solid apps on concrete APIs.
Local assumptions about the shape and organization of data creating localized APIs for applications over the Linked Data Platform interface exposed by Solid data pods provide local optimizations for data discovery, querying performance and more, but hurt the ecosystem as a whole, as assumptions and biases in the organization and discovery of data are not shared across the ecosystem.

The framing of Solid pods as a Knowledge Graph exposed over a multitude of APIs contrary to a data source organized using the Linked Data Platform specification enables us to think more about 
with the goal of reducing local assumptions and optimizations in apps for reasons of longevity. The API over which data is exposed over the Web is a means to an end, and should not define the platform. -->

      <p><span class="todo">What’s in a Pod? It’s in the eye of the beholder.</span></p>

    </div>
</section>

  <section id="acknowledgements" inlist="" rel="schema:hasPart" resource="#acknowledgements">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Acknowledgements</h2>

      <p>Supported by SolidLab Vlaanderen (Flemish Goverment, EWI and RRF project V023/10)</p>

    </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dspace.mit.edu/handle/1721.1/91861" typeof="schema:Thesis">Presbrey, J.W.: Linked data platform for web applications. <a href="https://dspace.mit.edu/handle/1721.1/91861">https:/​/​dspace.mit.edu/handle/1721.1/91861</a> (2014).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="https://solid.github.io/web-access-control-spec/" typeof="schema:CreativeWork">Web Access Control (WAC). World Wide Web Consortium, <a href="https://solid.github.io/web-access-control-spec/">https:/​/​solid.github.io/web-access-control-spec/</a></dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://solid.github.io/authorization-panel/acp-specification/" typeof="schema:CreativeWork">Access Control Policy (ACP). World Wide Web Consortium, <a href="https://solid.github.io/authorization-panel/acp-specification/">https:/​/​solid.github.io/authorization-panel/acp-specification/</a></dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#sambra_solid_nodate" typeof="schema:Article">Sambra, A.V., Mansour, E., Hawke, S., Zereba, M., Greco, N., Ghanem, A., Zagidulin, D., Aboulnaga, A., Berners-Lee, T.: Solid: A Platform for Decentralized Social Applications Based on Linked Data. 16</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-37439-6_1" typeof="schema:Chapter">Fensel, D., Şimşek, U., Angele, K., Huaman, E., Kärle, E., Panasiuk, O., Toma, I., Umbrich, J., Wahler, A.: Introduction: What Is a Knowledge Graph? In: Fensel, D., Şimşek, U., Angele, K., Huaman, E., Kärle, E., Panasiuk, O., Toma, I., Umbrich, J., and Wahler, A. (eds.) Knowledge Graphs: Methodology, Tools and Selected Use Cases. pp. 1–10. Springer International Publishing, Cham (2020). doi:10.1007/978-3-030-37439-6_1</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/" typeof="schema:CreativeWork">Verborgh, R.: Reflections of knowledge. <a href="https://ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/">https:/​/​ruben.verborgh.org/blog/2021/12/23/reflections-of-knowledge/</a> (2021).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-030-00668-6_15" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: A Modular SPARQL Query Engine for the Web. In: Vrandečić, D., Bontcheva, K., Suárez-Figueroa, M.C., Presutti, V., Celino, I., Sabou, M., Kaffee, L.-A., and Simperl, E. (eds.) The Semantic Web – ISWC 2018. pp. 239–255. Springer International Publishing, Cham (2018). doi:10.1007/978-3-030-00668-6_15</dd>
</dl>
</section>
</footer>



</body>
</html>
